<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>VATSIM AWOSD</title>
<style>
/* ========== –ë–ê–ó–û–í–´–ï –°–¢–ò–õ–ò ========== */
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',sans-serif;background:#f0f0f0;transition:all .3s ease}
body.dark{background:#1a1a1a;color:#fff}
.container{padding:min(10px,1vw);margin:0 auto;height:100vh;display:flex;flex-direction:column;min-height:600px;max-height:100vh;overflow:hidden;max-width:100vw;box-sizing:border-box}

/* ========== –ö–û–ù–¢–†–û–õ–´ ========== */
.controls{display:flex;gap:8px;margin-bottom:10px;align-items:center;flex-wrap:wrap;flex-shrink:0;justify-content:space-between}
.controls-left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
select,input{padding:4px 8px;border:1px solid #ccc;border-radius:4px;background:white;font-size:12px;height:28px}
.dark select,.dark input{background:#333;border-color:#555;color:white}

.header-buttons{display:flex;align-items:center;gap:8px;margin-left:auto}
.header-btn{padding:4px 12px;border:1px solid #ccc;border-radius:4px;background:white;font-size:11px;height:28px;cursor:pointer;transition:all 0.2s}
.header-btn:hover{background:#f0f0f0;border-color:#999}
.dark .header-btn{background:#333;border-color:#555;color:white}
.dark .header-btn:hover{background:#444;border-color:#777}
.version{font-size:10px;color:#666;font-weight:bold;padding:4px 8px}
.dark .version{color:#ccc}

.main-layout{display:grid;grid-template-columns:35% 30% 35%;gap:min(10px,1vw);margin-bottom:min(10px,1vh);flex:1.3;min-height:0;max-width:100%}
.bottom-section{grid-column:1 / -1;flex:0 0 auto;height:clamp(70px,8.4vh,84px)}
.block{background:white;border-radius:6px;padding:min(12px,1vw);box-shadow:0 1px 5px rgba(0,0,0,.1);display:flex;flex-direction:column;overflow:hidden;min-height:0}
.dark .block{background:#2a2a2a;box-shadow:0 1px 5px rgba(255,255,255,.1)}

/* ========== –°–¢–ê–¢–£–° –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø ========== */
.connection-status{display:flex;align-items:center;gap:5px;font-size:10px;color:#666}
.connection-status.connected{color:#28a745}
.connection-status.error{color:#dc3545}
.connection-status.loading{color:#ffc107}
.status-indicator{width:8px;height:8px;border-radius:50%;background:currentColor;animation:pulse 2s infinite}
.dark .connection-status{color:#999}
.dark .connection-status.connected{color:#40c767}
.dark .connection-status.error{color:#e74c3c}

@keyframes pulse {
0% { opacity: 1; }
50% { opacity: 0.5; }
100% { opacity: 1; }
}

/* ========== –ò–ù–î–ò–ö–ê–¢–û–† –ó–ê–ì–†–£–ó–ö–ò CSV ========== */
.csv-loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px;border-radius:8px;z-index:1000;display:none;text-align:center}
.csv-loading.show{display:block}
.loading-spinner{width:40px;height:40px;border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 10px}
@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}
.csv-info{font-size:12px;color:#ccc;margin-top:10px}

/* ========== –¶–ï–ù–¢–†–ê–õ–¨–ù–´–ô –ë–õ–û–ö ========== */
.block-1{display:flex;flex-direction:column;align-items:center;text-align:center;gap:min(2px,.2vh);font-size:clamp(16px,1.6vw,22px);padding:min(6px,.6vw);overflow-y:auto}
.block-1 *{font-size:inherit!important}
.icao-section{text-align:center;margin-bottom:min(4px,.4vh)}
.block-1 .icao-input{text-align:center;width:clamp(140px,16vw,200px);font-size:clamp(16px,1.6vw,22px);height:clamp(28px,3vh,35px)}
.weather-data{display:flex;flex-direction:column;align-items:center;flex:1;gap:min(2px,.2vh);margin-top:min(20px,2vh)}
.weather-data>*{margin-bottom:0;flex-shrink:0}

/* ========== –í–†–ï–ú–Ø –ò –í–û–°–•–û–î/–ó–ê–•–û–î ========== */
.sunrise-sunset-row{display:flex;gap:min(6px,.6vw);align-items:center;margin-bottom:min(24px,2.4vh)}
.sunrise-sunset-item{display:flex;flex-direction:column;align-items:center;gap:1px}
.sunrise-sunset-item .section-label{font-size:clamp(11px,1.1vw,14px)!important}
.sunrise-sunset-item .data-field{width:clamp(72px,7.2vw,104px);font-size:clamp(13px,1.3vw,18px)!important}
.sunrise-sunset-item .data-value{font-size:clamp(13px,1.3vw,18px)!important}

/* ========== –ü–û–ì–û–î–ù–´–ï –ü–û–õ–Ø ========== */
.weather-row{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;width:100%;gap:min(6px,.6vw);margin:min(4px,.4vh) 0}
.weather-row .section-label{color:#666;text-align:right;font-size:clamp(14px,1.4vw,18px);white-space:nowrap;justify-self:end}
.weather-row .data-field{width:max(80px,7vw);text-align:center;padding:min(4px,.4vw);background:#f8f8f8;border-radius:3px;justify-self:center}
.weather-row .units{color:#666;text-align:left;font-size:clamp(14px,1.4vw,18px);justify-self:start}
.dark .weather-row .section-label,.dark .weather-row .units{color:#ccc}

/* –î–∞–≤–ª–µ–Ω–∏–µ QNH - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ */
.weather-row+.weather-row.pressure-row{margin-top:min(-6px,-.6vh)}
.weather-row.pressure-row .section-label{font-size:clamp(10px,1.0vw,13px)!important}
.weather-row.pressure-row .data-field{font-size:clamp(10px,1.0vw,13px)!important}
.weather-row.pressure-row .units{font-size:clamp(10px,1.0vw,13px)!important}
.weather-row.pressure-row .data-value{font-size:clamp(11px,1.1vw,14px)!important}
.weather-row:nth-child(6){margin-bottom:min(24px,2.4vh)!important}

/* ========== –ë–õ–û–ö–ò –Ø–í–õ–ï–ù–ò–ô –ò –û–ë–õ–ê–ß–ù–û–°–¢–ò ========== */
.weather-phenomena-block,.cloudiness-block,.special-conditions-block{width:100%;text-align:center;display:flex;flex-direction:column;align-items:center;margin:min(8px,.8vh) 0}
.weather-phenomena-block .section-label,.cloudiness-block .section-label,.special-conditions-block .section-label{text-align:center!important;width:100%!important;margin-bottom:min(5px,.5vh)!important}
.weather-phenomena-block .data-field,.cloudiness-block .data-field,.special-conditions-block .data-field{width:clamp(288px,28.8vw,448px)!important;text-align:center!important}
.weather-phenomena-block .data-value,.cloudiness-block .data-value,.special-conditions-block .data-value{font-weight:normal!important;font-size:clamp(13px,1.3vw,18px)!important}

/* –û—Ç—Å—Ç—É–ø—ã */
.weather-phenomena-block{margin-top:min(24px,2.4vh)}
.cloudiness-block{margin-top:min(24px,2.4vh)}
.weather-row:has(+ .weather-phenomena-block){margin-bottom:0}
.weather-phenomena-block+.weather-row{margin-top:min(24px,2.4vh)}

/* ========== –û–ë–©–ò–ï –°–¢–ò–õ–ò –î–ê–ù–ù–´–• ========== */
.block-1 .section-label{color:#666;margin-bottom:1px;font-size:clamp(14px,1.4vw,18px);text-align:center}
.dark .block-1 .section-label{color:#ccc}
.block-1 .data-field{width:clamp(110px,11vw,150px);text-align:center;padding:min(4px,.4vw);background:#f8f8f8;border-radius:3px}
.data-field{text-align:center;padding:min(4px,.5vw);background:#f8f8f8;border-radius:3px}
.dark .data-field{background:#333}
.data-label{font-size:clamp(10px,1vw,12px);color:#666;margin-bottom:2px}
.dark .data-label{color:#ccc}
.data-value{font-size:clamp(16px,1.6vw,22px);font-weight:bold;line-height:.9}
#currentTime,#sunrise,#sunset{font-weight:normal!important}
.pressure-secondary{font-weight:normal!important}

/* ========== –ö–û–ú–ü–ê–° - –ë–ê–ó–û–í–´–ï –°–¢–ò–õ–ò ========== */
.compass-container{position:relative;width:80%;aspect-ratio:1;margin:0 auto 80px auto;flex-shrink:0;margin-top:min(30px,3vh);overflow:visible}
.compass{position:relative;width:100%;height:100%;border:2px solid #333;border-radius:50%;background:radial-gradient(circle,#fff 0%,#f0f0f0 100%);overflow:visible}
.dark .compass{border-color:#666;background:radial-gradient(circle,#2a2a2a 0%,#1a1a1a 100%)}
.compass-mark{position:absolute;background:#333}
.compass-mark.minor{width:1px;height:12px}
.compass-mark.major{width:2px;height:18px}
.dark .compass-mark{background:#ccc}
.compass-number{position:absolute;font-size:clamp(12px,1.8vw,20px);font-weight:bold;width:24px;text-align:center}

/* ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –í–ï–¢–†–ê ========== */
.wind-display{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;background:rgba(255,255,255,.9);padding:min(8px,.8vw);border-radius:6px;border:1px solid #ccc;min-width:80px}
.dark .wind-display{background:rgba(42,42,42,.9);border-color:#555}
.wind-direction{font-size:clamp(18px,2vw,26px);font-weight:bold;cursor:pointer}
.wind-speed{font-size:clamp(16px,1.8vw,22px);color:#333;cursor:pointer;line-height:1.2}
.dark .wind-speed{color:#ccc}
.wind-unit{font-size:clamp(12px,1.2vw,16px);color:#666;cursor:pointer}

/* –°—Ç—Ä–µ–ª–∫–∞ –≤–µ—Ç—Ä–∞ */
.wind-arrow{position:absolute;width:18px;height:25%;background:#4A90E2;transform-origin:top center;z-index:10;opacity:0.5}
.wind-arrow::after{content:'';position:absolute;bottom:-12px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:15px solid transparent;border-right:15px solid transparent;border-top:18px solid #4A90E2;opacity:1}
.dark .wind-arrow{background:#6BB6FF}
.dark .wind-arrow::after{border-top-color:#6BB6FF}

/* –°–µ–∫—Ç–æ—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞ */
.wind-sector{position:absolute;top:50%;left:50%;width:calc(100% + 20px);height:calc(100% + 20px);border-radius:50%;transform:translate(-50%,-50%);transform-origin:center;display:none;pointer-events:none;z-index:8;border:6px solid transparent}
.wind-sector.variable{display:block}

/* ========== –í–ü–ü ========== */
.runway-display{position:absolute;top:50%;left:50%;width:70%;height:24px;background:transparent;border:3px solid #333;transform:translate(-50%,-50%);border-radius:6px}
.dark .runway-display{border-color:#ccc}
.runway-display.left-landing::before{content:'';position:absolute;width:20%;height:2px;background:repeating-linear-gradient(to right,#333 0px,#333 4px,transparent 4px,transparent 8px);left:5%;top:50%;transform:translateY(-50%);z-index:16}
.runway-display.left-landing::after{content:'';position:absolute;width:0;height:0;border-left:8px solid #333;border-top:4px solid transparent;border-bottom:4px solid transparent;left:25%;top:50%;transform:translateY(-50%);z-index:16}
.runway-display.right-landing::before{content:'';position:absolute;width:20%;height:2px;background:repeating-linear-gradient(to left,#333 0px,#333 4px,transparent 4px,transparent 8px);right:5%;top:50%;transform:translateY(-50%);z-index:16}
.runway-display.right-landing::after{content:'';position:absolute;width:0;height:0;border-right:8px solid #333;border-top:4px solid transparent;border-bottom:4px solid transparent;right:25%;top:50%;transform:translateY(-50%);z-index:16}
.dark .runway-display.left-landing::before{background:repeating-linear-gradient(to right,#ccc 0px,#ccc 4px,transparent 4px,transparent 8px)}
.dark .runway-display.right-landing::before{background:repeating-linear-gradient(to left,#ccc 0px,#ccc 4px,transparent 4px,transparent 8px)}
.dark .runway-display.left-landing::after{border-left-color:#ccc}
.dark .runway-display.right-landing::after{border-right-color:#ccc}

/* ========== –ö–û–ú–ü–û–ù–ï–ù–¢–´ –í–ï–¢–†–ê ========== */
.lateral-component,.headwind-component{position:absolute;top:-30px;font-size:clamp(10px,1vw,12px);background:#f8f8f8;padding:2px 6px;border-radius:3px;z-index:5;width:max(50px,5vw);text-align:center}
.lateral-component{left:-45px}
.headwind-component{right:-45px}
.lateral-component .data-label,.headwind-component .data-label{position:absolute;top:100%;left:50%;transform:translateX(-50%);margin-top:2px;background:transparent;font-size:clamp(8px,0.8vw,10px)}
.friction-coefficient{position:absolute;bottom:-30px;right:-45px;font-size:clamp(10px,1vw,12px);background:#f8f8f8;padding:2px 6px;border-radius:3px;z-index:5;width:max(50px,5vw);text-align:center}
.friction-coefficient .data-label{position:absolute;bottom:100%;left:50%;transform:translateX(-50%);margin-bottom:2px;background:transparent;font-size:clamp(8px,0.8vw,10px)}
.dark .lateral-component,.dark .headwind-component,.dark .friction-coefficient{background:#333;color:#ccc}

/* ========== COMPASS-INFO ========== */
.compass-info{display:grid;grid-template-columns:30% 40% 30%;grid-template-rows:auto auto;gap:min(6px,0.6vw);margin-top:min(10px,1vh);font-size:clamp(10px,1vw,13px);width:100%}

/* –ë–∞–∑–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ compass-info */
.compass-info-item{display:flex;align-items:center;padding:min(6px,.6vw) min(8px,.8vw);border-radius:4px}
.compass-info-item .section-label,.compass-info-item .state-label,.compass-info-item .qfe-label{color:#333;font-size:clamp(11px,1.1vw,14px);font-weight:bold;min-width:35px}
.dark .compass-info-item .section-label,.dark .compass-info-item .state-label,.dark .compass-info-item .qfe-label{color:#ccc}
.compass-info-item .data-field,.compass-info-item .state-value{background:#f8f8f8;padding:min(4px,.4vw) min(8px,.8vw);border-radius:3px;text-align:center;width:60px;flex:1}
.dark .compass-info-item .data-field,.dark .compass-info-item .state-value{background:#333;color:#fff}
.compass-info-item .units{color:#666;font-size:clamp(11px,1.1vw,14px)}
.dark .compass-info-item .units{color:#999}

/* RVR –∏ ELEV - –ª–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ */
.rvr-row{grid-column:1;grid-row:1;flex-direction:row;gap:min(6px,.6vw);justify-content:center}
.elev-row{grid-column:1;grid-row:2;flex-direction:row;gap:min(6px,.6vw);justify-content:center}

/* QFE - —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–æ–ª–æ–Ω–∫–∞ */
.qfe-row{grid-column:2;grid-row:1 / span 2;flex-direction:column;align-items:center;gap:min(3px,.3vw);padding:min(8px,.8vw)}
.qfe-row .qfe-fields{display:flex;flex-direction:column;gap:min(3px,.3vw)}
.qfe-row .qfe-field{display:flex;flex-direction:row;align-items:center;gap:min(6px,.6vw)}
.qfe-row .qfe-field .qfe-label{color:#333;font-size:clamp(11px,1.1vw,14px);font-weight:bold;min-width:35px}
.dark .qfe-row .qfe-field .qfe-label{color:#ccc}
.qfe-row .qfe-field .data-field{background:#f8f8f8;padding:min(4px,.4vw) min(8px,.8vw);border-radius:3px;text-align:center;width:60px}
.dark .qfe-row .qfe-field .data-field{background:#333;color:#fff}
.qfe-row .qfe-field .units{color:#666;font-size:clamp(11px,1.1vw,14px);min-width:45px;text-align:left}
.dark .qfe-row .qfe-field .units{color:#999}
.qfe-row .qfe-field.primary .data-field{font-size:clamp(13px,1.3vw,17px);font-weight:bold}
.qfe-row .qfe-field.secondary .data-field{font-size:clamp(11px,1.1vw,14px);font-weight:normal}

/* RWY STATE - –ø—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ */
.runway-state-row{grid-column:3;grid-row:1 / span 2;flex-direction:column;align-items:center;gap:min(3px,.3vw);padding:min(8px,.8vw)}
.runway-state-item{display:flex;flex-direction:row;align-items:center;gap:min(6px,.6vw)}
.runway-state-item .state-label{color:#333;font-size:clamp(11px,1.1vw,14px);font-weight:bold;min-width:35px}
.dark .runway-state-item .state-label{color:#ccc}
.runway-state-item .state-value{background:#f8f8f8;padding:min(4px,.4vw) min(8px,.8vw);border-radius:3px;font-size:clamp(11px,1.1vw,14px);text-align:center;width:60px;flex:1}
.dark .runway-state-item .state-value{background:#333;color:#ccc}
.runway-state-item.surface .state-value{font-weight:bold}
.runway-state-item.friction{display:none}

/* ========== –ü–†–û–ì–ù–û–ó ========== */
.forecast-section{background:white;border-radius:6px;padding:min(8px,.8vw);box-shadow:0 1px 5px rgba(0,0,0,.1);height:100%;overflow:hidden;font-size:clamp(10px,1vw,12px);display:flex;flex-direction:column;justify-content:space-between}
.dark .forecast-section{background:#2a2a2a;box-shadow:0 1px 5px rgba(255,255,255,.1)}
.forecast-field{margin:2px 0;padding:0;background:transparent;border-radius:0;display:flex;align-items:center;gap:8px}
.forecast-field .forecast-label{color:#666;min-width:max(100px,10vw);text-align:right;font-size:clamp(10px,1vw,12px);font-weight:normal;margin-right:min(4px,.4vw)}
.forecast-field .forecast-value{flex:1;background:#f8f8f8;padding:3px 6px;border-radius:3px;font-size:clamp(10px,1vw,12px);word-break:break-all}
.dark .forecast-field .forecast-label{color:#ccc}
.dark .forecast-field .forecast-value{background:#333}

/* ========== –°–ï–õ–ï–ö–¢–û–† –í–ü–ü ========== */
.runway-selector{margin-bottom:min(10px,1vh);display:flex;justify-content:center}
.runway-selector select,.runway-display-label{text-align:center;width:clamp(140px,16vw,200px);font-size:clamp(12px,1.4vw,16px);height:clamp(28px,3vh,35px);padding:2px 6px;border:1px solid #ccc;border-radius:4px;background:white}
.runway-display-label{display:flex;align-items:center;justify-content:center;font-weight:bold;color:#333}
.dark .runway-selector select,.dark .runway-display-label{background:#333;border-color:#555;color:white}

/* ========== –ú–ï–î–ò–ê-–ó–ê–ü–†–û–°–´ ========== */
@media (max-width:1400px){.main-layout{grid-template-columns:34% 32% 34%}}
@media (max-width:1200px){.main-layout{grid-template-columns:32% 36% 32%}}
@media (max-width:900px){
    .main-layout{grid-template-columns:30% 40% 30%;gap:min(6px,1vh)}
    .container{padding:min(6px,1vw)}
    .block{padding:min(8px,1.2vw)}
    .compass-container{width:75%;margin-bottom:10px}
    .compass-info{grid-template-columns:25% 50% 25%;gap:min(4px,0.4vw)}
}
@media (max-width:600px){
    .main-layout{grid-template-columns:28% 44% 28%;gap:min(4px,.6vh)}
    .block{padding:min(6px,1vw)}
    .compass-container{width:70%;margin-bottom:8px}
    .compass-info{grid-template-columns:20% 60% 20%;gap:min(3px,0.3vw)}
}
</style>
</head>
<body>
<div class="csv-loading" id="csvLoading">
  <div class="loading-spinner"></div>
  <div>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∞—ç—Ä–æ–ø–æ—Ä—Ç–æ–≤...</div>
  <div class="csv-info">–û–±—Ä–∞–±–æ—Ç–∫–∞ airports.csv –∏ runways.csv</div>
</div>

<div class="container">
<div class="controls">
<div class="controls-left">
<select id="courseType">
<option value="true">True</option>
<option value="magnetic">Magnetic</option>
</select>
<select id="theme">
<option value="auto">Auto</option>
<option value="light">Light</option>
<option value="dark">Dark</option>
</select>
<select id="language">
<option value="en">English</option>
<option value="ru">–†—É—Å—Å–∫–∏–π</option>
</select>
<div class="connection-status" id="connectionStatus">
<div class="status-indicator"></div>
<span>Ready to load local data</span>
</div>
</div>
<div class="header-buttons">
<div class="version">v1.0.16</div>
<button id="aboutBtn" class="header-btn">
<span class="en">About</span>
<span class="ru" style="display:none">–û –ø—Ä–æ–µ–∫—Ç–µ</span>
</button>
<button id="supportBtn" class="header-btn">
<span class="en">Support</span>
<span class="ru" style="display:none">–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å</span>
</button>
</div>
</div>

<div class="main-layout">
<!-- –ë–ª–æ–∫ –∫–æ–º–ø–∞—Å–∞ 1 -->
<div class="block">
<div class="runway-selector">
<select id="runwaySelect">
<option value="">Enter ICAO code</option>
</select>
</div>
<div class="compass-container">
<div class="lateral-component compass-info-item">
<div class="data-value">-</div>
<div class="data-label" id="lateralLabel1">Side</div>
</div>
<div class="headwind-component compass-info-item">
<div class="data-value">-</div>
<div class="data-label" id="headwindLabel1">Head</div>
</div>
<div class="friction-coefficient compass-info-item">
<div class="data-value">-</div>
<div class="data-label" id="frictionLabel1">Breaking action</div>
</div>
<div class="compass" id="compass"></div>
<div class="wind-display">
<div class="wind-direction">---¬∞</div>
<div class="wind-speed">-</div>
<div class="wind-unit">kt</div>
</div>
</div>
<div class="compass-info"></div>
</div>

<!-- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –±–ª–æ–∫ -->
<div class="block block-1">
<div class="icao-section">
<input type="text" id="icaoInput" class="icao-input" placeholder="ICAO" maxlength="4">
</div>
<div class="weather-data">
<div class="section-label" id="timeLabel">Time UTC</div>
<div class="data-field">
<div class="data-value" id="currentTime">--:--</div>
</div>
<div class="sunrise-sunset-row">
<div class="sunrise-sunset-item">
<div class="section-label" id="sunriseLabel">Sunrise</div>
<div class="data-field">
<div class="data-value" id="sunrise">-</div>
</div>
</div>
<div class="sunrise-sunset-item">
<div class="section-label" id="sunsetLabel">Sunset</div>
<div class="data-field">
<div class="data-value" id="sunset">-</div>
</div>
</div>
</div>
<div class="weather-row">
<div class="section-label">QNH</div>
<div class="data-field"><div class="data-value">-</div></div>
<div class="units">hPa</div>
</div>
<div class="weather-row pressure-row">
<div class="section-label"></div>
<div class="data-field"><div class="data-value pressure-secondary">-</div></div>
<div class="units">mmHg</div>
</div>
<div class="weather-row pressure-row">
<div class="section-label"></div>
<div class="data-field"><div class="data-value pressure-secondary">-</div></div>
<div class="units">inHg</div>
</div>
<div class="weather-row">
<div class="section-label">T</div>
<div class="data-field"><div class="data-value">-</div></div>
<div class="units">¬∞C</div>
</div>
<div class="weather-row">
<div class="section-label">DP</div>
<div class="data-field"><div class="data-value">-</div></div>
<div class="units">¬∞C</div>
</div>
<div class="weather-phenomena-block">
<div class="section-label" id="weatherLabel">Weather</div>
<div class="data-field"><div class="data-value" id="weatherPhenomena">-</div></div>
</div>
<div class="weather-row">
<div class="section-label" id="morLabel">MOR</div>
<div class="data-field"><div class="data-value">-</div></div>
<div class="units">–º</div>
</div>
<div class="weather-row">
<div class="section-label" id="qbbLabel">QBB</div>
<div class="data-field"><div class="data-value">-</div></div>
<div class="units">–º</div>
</div>
<div class="cloudiness-block">
<div class="section-label" id="skyConditionLabel">Sky condition</div>
<div class="data-field"><div class="data-value">-</div></div>
</div>
<div class="special-conditions-block">
<div class="section-label" id="specialLabel">Special conditions</div>
<div class="data-field"><div class="data-value" id="specialConditions">-</div></div>
</div>
</div>
</div>

<!-- –ë–ª–æ–∫ –∫–æ–º–ø–∞—Å–∞ 2 -->
<div class="block">
<div class="runway-selector">
<div class="runway-display-label" id="runwayDisplay2">--</div>
</div>
<div class="compass-container">
<div class="lateral-component compass-info-item">
<div class="data-value">-</div>
<div class="data-label" id="lateralLabel2">Side</div>
</div>
<div class="headwind-component compass-info-item">
<div class="data-value">-</div>
<div class="data-label" id="headwindLabel2">Head</div>
</div>
<div class="friction-coefficient compass-info-item">
<div class="data-value">-</div>
<div class="data-label" id="frictionLabel2">Breaking action</div>
</div>
<div class="compass" id="compass2"></div>
<div class="wind-display">
<div class="wind-direction">---¬∞</div>
<div class="wind-speed">-</div>
<div class="wind-unit">kt</div>
</div>
</div>
<div class="compass-info"></div>
</div>

<!-- –ù–∏–∂–Ω–∏–π –±–ª–æ–∫ -->
<div class="bottom-section">
<div class="forecast-section">
<div class="forecast-field">
<div class="forecast-label" id="forecastLabel">Weather forecast</div>
<div class="forecast-value">-</div>
</div>
<div class="forecast-field">
<div class="forecast-label">METAR</div>
<div class="forecast-value" id="metarCode">-</div>
</div>
</div>
</div>
</div>
</div>

<script>
// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
let currentMetarData = null;
let previousMetarData = null; // –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏
let currentRunwayData = null;
let updateInterval = null;
let globalAPI = null;
let userPreferredWindUnit = null;

// ========== –ò–°–¢–û–†–ò–Ø METAR (–ì–ò–ë–†–ò–î–ù–´–ô –ú–ï–¢–û–î) ==========

/**
 * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é METAR –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π —á–∞—Å —Å aviationweather.gov
 */
async function fetchMetarHistory(icao, hours = 1) {
  const url = `https://aviationweather.gov/api/data/metar?ids=${icao}&format=json&hours=${hours}`;

  try {
    console.log(`üì° –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ METAR –¥–ª—è ${icao} –∏–∑ API...`);

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();

    if (!data || data.length === 0) {
      console.warn(`‚ö†Ô∏è –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ METAR –¥–ª—è ${icao} –≤ API`);
      return [];
    }

    console.log(`‚úÖ –ü–æ–ª—É—á–µ–Ω–æ ${data.length} METAR –∑–∞–ø–∏—Å–µ–π –∏–∑ API`);

    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (—Å–∞–º—ã–π —Å—Ç–∞—Ä—ã–π –ø–µ—Ä–≤—ã–π)
    const sorted = data.sort((a, b) => {
      return new Date(a.obsTime) - new Date(b.obsTime);
    });

    return sorted;

  } catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏ –∏–∑ API:`, error);
    return [];
  }
}

/**
 * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ API –≤ —Ñ–æ—Ä–º–∞—Ç –Ω–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
 */
function convertApiMetarToAppFormat(apiMetar) {
  if (!apiMetar) return null;

  // –ü–∞—Ä—Å–∏–º —Å—ã—Ä–æ–π METAR —á–µ—Ä–µ–∑ –Ω–∞—à—É —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é
  const parsed = parseMetar(apiMetar.rawOb);

  // –î–æ–ø–æ–ª–Ω—è–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ API
  if (parsed.wind && apiMetar.wspd !== undefined) {
    parsed.wind.speed = apiMetar.wspd;
    parsed.wind.direction = apiMetar.wdir || 0;
    parsed.wind.gust = apiMetar.wgst || 0;
    parsed.wind.calm = apiMetar.wspd === 0;
  }

  return parsed;
}

/**
 * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç METAR –≤ localStorage
 */
function saveMetarToLocalHistory(icao, metarData) {
  try {
    const key = `metar_history_${icao}`;
    const now = new Date().toISOString();

    // –ü–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∏—Å—Ç–æ—Ä–∏—é
    let history = [];
    const stored = localStorage.getItem(key);
    if (stored) {
      history = JSON.parse(stored);
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
    history.push({
      timestamp: now,
      data: metarData
    });

    // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∑–∞–ø–∏—Å–µ–π
    if (history.length > 10) {
      history = history.slice(-10);
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º
    localStorage.setItem(key, JSON.stringify(history));
    console.log(`üíæ METAR —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ localStorage (–≤—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: ${history.length})`);

  } catch (e) {
    console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ localStorage:', e);
  }
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏–π METAR –∏–∑ localStorage
 */
function getPreviousMetarFromLocalHistory(icao) {
  try {
    const key = `metar_history_${icao}`;
    const stored = localStorage.getItem(key);

    if (!stored) {
      console.log('üìä –ù–µ—Ç –ª–æ–∫–∞–ª—å–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è', icao);
      return null;
    }

    const history = JSON.parse(stored);

    if (history.length < 2) {
      console.log('üìä –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–∞–ø–∏—Å–µ–π –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏');
      return null;
    }

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω–∏–π
    const previous = history[history.length - 2].data;
    console.log('‚úÖ –ü—Ä–µ–¥—ã–¥—É—â–∏–π METAR –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ localStorage');
    return previous;

  } catch (e) {
    console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è localStorage:', e);
    return null;
  }
}

/**
 * –ì–ò–ë–†–ò–î–ù–ê–Ø –ó–ê–ì–†–£–ó–ö–ê: API + localStorage
 */
async function loadMetarWithHistory(icao) {
  let previousFromAPI = null;
  let previousFromLocal = null;

  // 1. –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –∏–∑ API
  try {
    const apiHistory = await fetchMetarHistory(icao, 1);

    if (apiHistory.length >= 2) {
      // –ë–µ—Ä—ë–º –ø—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω–∏–π METAR –∏–∑ API
      previousFromAPI = convertApiMetarToAppFormat(apiHistory[apiHistory.length - 2]);
      console.log('‚úÖ –ü—Ä–µ–¥—ã–¥—É—â–∏–π METAR –ø–æ–ª—É—á–µ–Ω –∏–∑ API');
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –∏—Å—Ç–æ—Ä–∏—é');
  }

  // 2. –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ localStorage
  previousFromLocal = getPreviousMetarFromLocalHistory(icao);

  // 3. –ò—Å–ø–æ–ª—å–∑—É–µ–º —á—Ç–æ –¥–æ—Å—Ç—É–ø–Ω–æ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç API > localStorage)
  previousMetarData = previousFromAPI || previousFromLocal;

  if (!previousMetarData) {
    console.log('üìä –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (–ø–µ—Ä–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞)');
  }

  // 4. –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π METAR
  currentMetarData = await fetchMetarData(icao);

  // 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –≤ localStorage –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–∞–∑–∞
  saveMetarToLocalHistory(icao, currentMetarData);

  return currentMetarData;
}

// ========== –£–¢–ò–õ–ò–¢–´ ==========

function convertPressure(hpa) {
  return {
    hpa: hpa,
    mmhg: Math.round(hpa * 0.750062 * 1) / 1,
    inhg: Math.round(hpa * 0.02953 * 100) / 100
  };
}

function updateConnectionStatus(status, text) {
  const statusEl = document.getElementById('connectionStatus');
  if (!statusEl) return;
  statusEl.className = `connection-status ${status}`;
  statusEl.querySelector('span').textContent = text;
}

async function getAPI() {
  if (!globalAPI) {
    globalAPI = new OurAirportsAPI();
    await globalAPI.loadDatabase();
  }
  return globalAPI;
}

// ========== OURAIRPORTS API ==========

class OurAirportsAPI {
  constructor() {
    this.airports = new Map();
    this.loaded = false;
    this.loadingPromise = null;
  }

  async loadDatabase() {
    if (this.loaded) return true;
    if (this.loadingPromise) return this.loadingPromise;

    console.log('üîÑ –ó–∞–≥—Ä—É–∑–∫–∞ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö...');
    this.showCSVLoading(true);
    updateConnectionStatus('loading', 'Loading local data...');

    this.loadingPromise = this._loadLocalCSVFiles();
    return this.loadingPromise;
  }

  async _loadLocalCSVFiles() {
    try {
      const [airportsResponse, runwaysResponse] = await Promise.all([
        fetch('./airports.csv'),
        fetch('./runways.csv')
      ]);

      if (!airportsResponse.ok || !runwaysResponse.ok) {
        throw new Error('Cannot load CSV files');
      }

      const airportsData = await airportsResponse.text();
      const runwaysData = await runwaysResponse.text();

      await this._parseCSVData(airportsData, runwaysData);

      this.loaded = true;
      this.showCSVLoading(false);

      const stats = {
        airports: this.airports.size,
        totalRunways: Array.from(this.airports.values()).reduce((sum, airport) => sum + airport.runways.length, 0)
      };

      console.log(`‚úÖ Loaded ${stats.airports} airports with ${stats.totalRunways} runways`);
      updateConnectionStatus('connected', `${stats.airports} airports loaded`);

      return true;

    } catch (error) {
      console.error('‚ùå Failed to load CSV files:', error);
      this.showCSVLoading(false);
      updateConnectionStatus('error', 'CSV files required');
      throw new Error('CSV files are required');
    }
  }

  async _parseCSVData(airportsCSV, runwaysCSV) {
    const parseCSV = (text) => {
      const lines = text.split('\n');
      const headers = this._parseCSVLine(lines[0]);
      const data = [];

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const values = this._parseCSVLine(line);
        if (values.length >= headers.length) {
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index] || '';
          });
          data.push(row);
        }
      }
      return data;
    };

    const airportsData = parseCSV(airportsCSV);

    for (const row of airportsData) {
      const icao = row.ident;
      if (!icao || icao.length !== 4 || !icao.match(/^[A-Z0-9]{4}$/)) continue;
      if (row.type === 'closed') continue;

      this.airports.set(icao, {
        icao: icao,
        name: row.name || 'Unknown Airport',
        type: row.type || 'unknown',
        elevation_ft: parseFloat(row.elevation_ft) || 0,
        latitude: parseFloat(row.latitude_deg) || 0,
        longitude: parseFloat(row.longitude_deg) || 0,
        country: row.iso_country || '',
        iso_country: row.iso_country || '',
        iso_region: row.iso_region || '',
        municipality: row.municipality || '',
        continent: row.continent || '',
        runways: []
      });
    }

    const runwaysData = parseCSV(runwaysCSV);

    for (const row of runwaysData) {
      const icao = row.airport_ident;
      if (!this.airports.has(icao)) continue;
      if (row.closed === '1') continue;

      const runway = {
        le_ident: row.le_ident || '',
        he_ident: row.he_ident || '',
        le_elevation_ft: parseFloat(row.le_elevation_ft) || 0,
        he_elevation_ft: parseFloat(row.he_elevation_ft) || 0,
        le_heading_deg: parseFloat(row.le_heading_degT) || 0,
        he_heading_deg: parseFloat(row.he_heading_degT) || 180,
        length_ft: parseFloat(row.length_ft) || 0,
        width_ft: parseFloat(row.width_ft) || 0,
        surface: row.surface || 'ASP'
      };

      this.airports.get(icao).runways.push(runway);
    }

    const airportsWithRunways = new Map();
    for (const [icao, airport] of this.airports) {
      if (airport.runways && airport.runways.length > 0) {
        airportsWithRunways.set(icao, airport);
      }
    }
    this.airports = airportsWithRunways;
  }

  _parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current.trim());
    return result.map(val => val.replace(/^"|"$/g, ''));
  }

  showCSVLoading(show) {
    const loader = document.getElementById('csvLoading');
    if (loader) {
      loader.className = show ? 'csv-loading show' : 'csv-loading';
    }
  }

  async getRunwayData(icao) {
    await this.loadDatabase();
    const airport = this.airports.get(icao.toUpperCase());
    if (!airport || !airport.runways || airport.runways.length === 0) {
      throw new Error(`No runway data for ${icao}`);
    }

    return airport.runways.map(runway => ({
      leIdent: runway.le_ident,
      heIdent: runway.he_ident,
      leElevation: runway.le_elevation_ft * 0.3048,
      heElevation: runway.he_elevation_ft * 0.3048,
      leHeading: runway.le_heading_deg,
      heHeading: runway.he_heading_deg,
      length: runway.length_ft * 0.3048,
      width: runway.width_ft * 0.3048,
      surface: runway.surface
    }));
  }

  getRunwayElevation(runwayData, selectedRunway) {
    for (const runway of runwayData) {
      if (runway.leIdent === selectedRunway) return runway.leElevation;
      if (runway.heIdent === selectedRunway) return runway.heElevation;
    }
    return null;
  }

  calculateQFE(qnhHpa, elevationMeters) {
    if (!qnhHpa || elevationMeters === null) return null;
    const qfe = qnhHpa - (elevationMeters / 8.5);
    return Math.round(qfe);
  }

  getAirportInfo(icao) {
    const airport = this.airports.get(icao.toUpperCase());
    if (!airport) return null;

    return {
      icao: airport.icao,
      name: airport.name,
      latitude: airport.latitude,
      longitude: airport.longitude,
      country: airport.country,
      iso_region: airport.iso_region,
      municipality: airport.municipality,
      continent: airport.continent,
      elevation_ft: airport.elevation_ft
    };
  }
}

// ========== METAR –ü–ê–†–°–ï–† ==========

function parseMetar(metarString) {
  if (!metarString) return null;

  const parts = metarString.split(' ');
  const data = {
    raw: metarString,
    icao: parts[0],
    time: '',
    wind: { direction: 0, speed: 0, gust: 0, variable: false, calm: false },
    windUnit: 'kt',
    visibility: 0,
    weather: [],
    clouds: [],
    temperature: null,
    dewpoint: null,
    pressure: 0,
    runwayStates: []
  };

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];

    if (part.match(/^\d{6}Z$/)) {
      data.time = part;
    }

    if (part.match(/^\d{3}\d{2}(G\d{2})?KT$/)) {
      data.wind.direction = parseInt(part.substring(0, 3));
      data.wind.speed = parseInt(part.substring(3, 5));
      data.windUnit = 'kt';
      const gustMatch = part.match(/G(\d{2})/);
      data.wind.gust = gustMatch ? parseInt(gustMatch[1]) : 0;
    }

    if (part.match(/^\d{3}\d{2}(G\d{2})?MPS$/)) {
      data.wind.direction = parseInt(part.substring(0, 3));
      const speedMps = parseInt(part.substring(3, 5));
      data.wind.speed = speedMps;
      data.windUnit = '–º/—Å';
      const gustMatch = part.match(/G(\d{2})/);
      if (gustMatch) {
        const gustMps = parseInt(gustMatch[1]);
        data.wind.gust = gustMps;
      } else {
        data.wind.gust = 0;
      }
    }

    if (part === '00000KT' || part === '00000MPS') {
      data.wind.calm = true;
      data.wind.direction = 0;
      data.wind.speed = 0;
    }

    if (part.match(/^\d{3}V\d{3}$/)) {
      data.wind.variable = true;
      const winds = part.split('V');
      data.variableFrom = parseInt(winds[0]);
      data.variableTo = parseInt(winds[1]);
    }

    if (part.match(/^\d{4}$/) && parseInt(part) > 100) {
      data.visibility = parseInt(part);
    }

    if (part.match(/^M?\d{2}\/M?\d{2}$/)) {
      const temps = part.split('/');
      data.temperature = parseInt(temps[0].replace('M', '-'));
      data.dewpoint = parseInt(temps[1].replace('M', '-'));
    }

    if (part.match(/^Q\d{4}$/)) {
      data.pressure = parseInt(part.substring(1));
    }

    if (part.match(/^(SKC|CLR|FEW|SCT|BKN|OVC|NSC|NCD)\d{0,3}(CB|TCU)?$/)) {
      const coverage = part.match(/^(SKC|CLR|FEW|SCT|BKN|OVC|NSC|NCD)/)[1];
      const heightMatch = part.match(/\d{3}/);
      const height = heightMatch ? parseInt(heightMatch[0]) * 100 : null;
      const typeMatch = part.match(/(CB|TCU)$/);
      const type = typeMatch ? typeMatch[1] : null;

      data.clouds.push({
        coverage,
        height,
        type
      });
    }

    if (part.match(/^(\+|-|VC)?(MI|PR|BC|DR|BL|SH|TS|FZ)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP)?(BR|FG|FU|VA|DU|SA|HZ|PY)?(PO|SQ|FC|SS|DS)?$/)) {
      if (!part.match(/^(SKC|CLR|FEW|SCT|BKN|OVC|NSC|NCD|CAVOK|NOSIG|TEMPO|BECMG|RMK|Q\d{4}|R\d{2})/)) {
        data.weather.push(part);
      }
    }

    // –ü–ê–†–°–ò–ù–ì –°–û–°–¢–û–Ø–ù–ò–Ø –í–ü–ü - —Ñ–æ—Ä–º–∞—Ç R12L/620142 –∏–ª–∏ R12/620142
    // R - –ø—Ä–µ—Ñ–∏–∫—Å, 12 - –Ω–æ–º–µ—Ä –í–ü–ü, L/R/C - –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ), 620142 - —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    if (part.match(/^R\d{2}[LRC]?\/\d{6}$/)) {
      const runwayStateMatch = part.match(/^R(\d{2}[LRC]?)\/(\d)(\d)(\d{2})(\d{2})$/);
      if (runwayStateMatch) {
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –í–ü–ü: ${part}`);
        data.runwayStates.push({
          raw: part,
          runway: runwayStateMatch[1],        // 12L, 12R, 12C –∏–ª–∏ 12
          deposit: runwayStateMatch[2],       // 6 = Slush
          extent: runwayStateMatch[3],        // 2 = 11-25%
          depth: runwayStateMatch[4],         // 01 = 1mm
          friction: runwayStateMatch[5]       // 42 = 0.42
        });
      }
    }

    // –ü–ê–†–°–ò–ù–ì –°–û–°–¢–û–Ø–ù–ò–Ø –í–ü–ü - —Ñ–æ—Ä–º–∞—Ç 12L/620142 –∏–ª–∏ 12/620142 (–±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞ R)
    if (part.match(/^\d{2}[LRC]?\/\d{6}$/)) {
      const runwayStateMatch = part.match(/^(\d{2}[LRC]?)\/(\d)(\d)(\d{2})(\d{2})$/);
      if (runwayStateMatch) {
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –í–ü–ü: ${part}`);
        data.runwayStates.push({
          raw: part,
          runway: runwayStateMatch[1],
          deposit: runwayStateMatch[2],
          extent: runwayStateMatch[3],
          depth: runwayStateMatch[4],
          friction: runwayStateMatch[5]
        });
      }
    }

    // –ü–ê–†–°–ò–ù–ì –°–û–°–¢–û–Ø–ù–ò–Ø –í–°–ï–• –í–ü–ü - —Ñ–æ—Ä–º–∞—Ç 88/620142
    if (part.match(/^88\/\d{6}$/)) {
      const allRunwaysMatch = part.match(/^(88)\/(\d)(\d)(\d{2})(\d{2})$/);
      if (allRunwaysMatch) {
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—Å–µ—Ö –í–ü–ü: ${part}`);
        data.runwayStates.push({
          raw: part,
          runway: allRunwaysMatch[1],
          deposit: allRunwaysMatch[2],
          extent: allRunwaysMatch[3],
          depth: allRunwaysMatch[4],
          friction: allRunwaysMatch[5]
        });
      }
    }
  }

  const remarksSection = extractRemarksSection(metarString);
  if (remarksSection) {
    const currentLang = document.getElementById('language')?.value || 'en';
    data.specialConditions = parseSpecialConditionsFromRemarks(remarksSection, currentLang);
  } else {
    data.specialConditions = { qfe: null, qbb: null, other: [] };
  }

  console.log(`üìä Parsed METAR runwayStates:`, data.runwayStates);

  return data;
}

function extractRemarksSection(metarString) {
  if (!metarString) return '';
  const rmkIndex = metarString.indexOf(' RMK ');
  if (rmkIndex === -1) return '';

  let remarksSection = metarString.substring(rmkIndex + 5);
  remarksSection = remarksSection.replace(/\s*TEMPO\s+.*$/i, '');
  remarksSection = remarksSection.replace(/\s*BECMG\s+.*$/i, '');
  remarksSection = remarksSection.replace(/\s*PROB\d{2}\s+.*$/i, '');
  remarksSection = remarksSection.replace(/\s*=\s*$/, '');

  return remarksSection.trim();
}

function parseSpecialConditionsFromRemarks(remarksString, language = 'ru') {
  if (!remarksString || remarksString.trim() === '') {
    return { qfe: null, qbb: null, other: [] };
  }

  console.log(`üîç Parsing remarks: "${remarksString}"`);

  const result = { qfe: null, qbb: null, other: [] };
  const parts = remarksString.split(/\s+/);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];

    if (part.match(/^QFE/i)) {
      const qfeFormatSlash = part.match(/^QFE(\d{3,4})\/0?(\d{3,4})$/i);
      if (qfeFormatSlash) {
        result.qfe = parseInt(qfeFormatSlash[2]);
        console.log(`‚úÖ QFE from remarks (slash format): ${result.qfe} hPa`);
      } else {
        const qfeFormatSimple = part.match(/^QFE(\d{3,4})$/i);
        if (qfeFormatSimple) {
          const value = parseInt(qfeFormatSimple[1]);

          if (value >= 600 && value < 800) {
            result.qfe = Math.round(value / 0.750062);
            console.log(`‚úÖ QFE from remarks: ${value} mmHg ‚Üí ${result.qfe} hPa`);
          } else if (value >= 800 && value <= 1100) {
            result.qfe = value;
            console.log(`‚úÖ QFE from remarks: ${result.qfe} hPa`);
          } else {
            result.qfe = value;
            console.log(`‚ö†Ô∏è QFE from remarks (uncertain range): ${result.qfe} hPa`);
          }
        }
      }
    }
    else if (part.match(/^QBB\d{3,4}$/i)) {
      const qbbMatch = part.match(/^QBB(\d{3,4})$/i);
      if (qbbMatch) {
        result.qbb = parseInt(qbbMatch[1]);
        console.log(`‚úÖ QBB from remarks: ${result.qbb} m`);
      }
    }
    else if (part.match(/^MT$/i) && i + 1 < parts.length && parts[i + 1].match(/^OBSC$/i)) {
      result.other.push({
        code: `${part} ${parts[i + 1]}`,
        decoded: language === 'ru' ? '–ì–æ—Ä—ã –∑–∞–∫—Ä—ã—Ç—ã' : 'Mountains obscured'
      });
      i++;
    }
    else if (part.match(/^MAST$/i) && i + 1 < parts.length && parts[i + 1].match(/^OBS$/i)) {
      result.other.push({
        code: `${part} ${parts[i + 1]}`,
        decoded: language === 'ru' ? '–ú–∞—á—Ç—ã —Å–æ–∑–¥–∞—é—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è' : 'Mast obstacles'
      });
      i++;
    }
    else if (part.match(/^OBST$/i) && i + 1 < parts.length && parts[i + 1].match(/^OBSC$/i)) {
      result.other.push({
        code: `${part} ${parts[i + 1]}`,
        decoded: language === 'ru' ? '–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –Ω–µ –≤–∏–¥–Ω—ã' : 'Obstacles obscured'
      });
      i++;
    }
  }

  return result;
}

async function fetchMetarData(icao) {
  updateConnectionStatus('loading', 'Loading METAR...');

  try {
    const response = await fetch(`https://metar.vatsim.net/${icao.toUpperCase()}`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    const metarText = await response.text();
    if (!metarText || metarText.includes('No METAR available')) {
      throw new Error('No METAR data available');
    }

    const parsedData = parseMetar(metarText.trim());
    if (parsedData) {
      updateConnectionStatus('connected', 'METAR loaded');
      return parsedData;
    } else {
      throw new Error('Failed to parse METAR');
    }

  } catch (error) {
    console.error('METAR fetch error:', error);
    updateConnectionStatus('error', 'METAR error');
    return generateDemoData(icao);
  }
}

function generateDemoData(icao) {
  return {
    raw: `${icao} NO METAR`,
    icao: icao,
    time: '121853Z',
    wind: { direction: 190, speed: 5, gust: 0, variable: false, calm: false },
    windUnit: 'kt',
    visibility: 9999,
    weather: [],
    clouds: [
      { coverage: 'FEW', height: 2000 },
      { coverage: 'SCT', height: 8000 }
    ],
    temperature: 12,
    dewpoint: 8,
    pressure: 1013
  };
}

// ========== –ß–ê–°–û–í–´–ï –ü–û–Ø–°–ê ==========

function getTimezoneByRegion(airport) {
  if (!airport) return 0;

  const country = airport.country || airport.iso_country || '';
  const region = airport.iso_region || '';
  const longitude = airport.longitude || 0;

  if (country === 'RU') {
    const regionTimezones = {
      'RU-KGD': 2,
      'RU-MOW': 3, 'RU-SPE': 3, 'RU-LEN': 3, 'RU-MOS': 3,
      'RU-SAM': 4, 'RU-SAR': 4,
      'RU-SVE': 5, 'RU-CHE': 5,
      'RU-OMS': 6, 'RU-NVS': 6,
      'RU-KYA': 7,
      'RU-IRK': 8,
      'RU-ZAB': 9,
      'RU-PRI': 10,
      'RU-MAG': 11,
      'RU-KAM': 12
    };

    const timezone = regionTimezones[region];
    if (timezone !== undefined) return timezone;

    if (longitude < 30) return 2;
    if (longitude < 45) return 3;
    if (longitude < 60) return 4;
    if (longitude < 75) return 5;
    if (longitude < 105) return 6;
    if (longitude < 120) return 7;
    if (longitude < 135) return 8;
    if (longitude < 150) return 9;
    if (longitude < 165) return 10;
    if (longitude < 175) return 11;
    return 12;
  }

  const europeanCountries = {
    'GB': 0, 'IE': 0, 'PT': 0,
    'FR': 1, 'ES': 1, 'DE': 1, 'IT': 1,
    'FI': 2, 'EE': 2, 'GR': 2,
    'BY': 3, 'TR': 3
  };

  if (europeanCountries.hasOwnProperty(country)) {
    return europeanCountries[country];
  }

  const otherCountries = {
    'CN': 8, 'JP': 9, 'IN': 5.5, 'AU': 10
  };

  if (otherCountries.hasOwnProperty(country)) {
    return otherCountries[country];
  }

  let offset = Math.round(longitude / 15);
  return Math.max(-12, Math.min(14, offset));
}

function getAirportTimezoneFromCSV(icao) {
  if (!globalAPI || !globalAPI.airports) return 0;

  const airport = globalAPI.airports.get(icao.toUpperCase());
  if (!airport) return 0;

  return getTimezoneByRegion(airport);
}

// ========== –í–û–°–•–û–î/–ó–ê–•–û–î ==========

async function updateSunriseSunset() {
  const currentIcao = document.getElementById('icaoInput').value;

  if (!currentIcao || currentIcao.length !== 4) {
    document.getElementById('sunrise').textContent = '-';
    document.getElementById('sunset').textContent = '-';
    window.airportData = null;
    return;
  }

  try {
    const api = await getAPI();
    const airport = api.getAirportInfo(currentIcao);

    if (airport && airport.latitude && airport.longitude) {
      const sunTimes = calculateSunriseSunset(airport.latitude, airport.longitude);
      const timezoneOffset = getAirportTimezoneFromCSV(currentIcao);

      window.airportData = {
        icao: currentIcao,
        latitude: airport.latitude,
        longitude: airport.longitude,
        name: airport.name,
        country: airport.country,
        iso_region: airport.iso_region,
        municipality: airport.municipality,
        sunriseUTC: sunTimes.sunrise,
        sunsetUTC: sunTimes.sunset,
        timezoneOffset: timezoneOffset,
        sunType: sunTimes.type || 'normal'
      };

      updateTimeDisplay();

    } else {
      throw new Error(`Airport coordinates not found for ${currentIcao}`);
    }
  } catch (error) {
    console.error('‚ùå Error loading airport data:', error);
    document.getElementById('sunrise').textContent = '-';
    document.getElementById('sunset').textContent = '-';
    window.airportData = null;
  }
}

function calculateSunriseSunset(latitude, longitude, date = new Date()) {
  try {
    if (Math.abs(latitude) > 90 || Math.abs(longitude) > 180) {
      return { sunrise: '-', sunset: '-' };
    }

    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();

    const julianDay = getJulianDay(year, month, day);
    const n = julianDay - 2451545.0;
    const T = n / 36525.0;

    const L0 = (280.46646 + T * (36000.76983 + T * 0.0003032)) % 360;
    const M = (357.52911 + T * (35999.05029 - 0.0001537 * T)) % 360;
    const Mrad = M * Math.PI / 180;

    const C = Math.sin(Mrad) * (1.914602 - T * (0.004817 + 0.000014 * T)) +
              Math.sin(2 * Mrad) * (0.019993 - 0.000101 * T) +
              Math.sin(3 * Mrad) * 0.000289;

    const theta = L0 + C;
    const lambdaRad = (theta - 0.00569) * Math.PI / 180;

    const epsilon0 = 23 + (26 + ((21.448 - T * (46.8150 + T * (0.00059 - T * 0.001813)))) / 60) / 60;
    const epsilonRad = epsilon0 * Math.PI / 180;

    const delta = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad));

    const latRad = latitude * Math.PI / 180;
    const h0 = -0.8333;
    const cosH = (Math.sin(h0 * Math.PI / 180) - Math.sin(latRad) * Math.sin(delta)) /
                 (Math.cos(latRad) * Math.cos(delta));

    if (cosH > 1) {
      return { sunrise: '--:--', sunset: '--:--', type: 'polar_night' };
    }
    if (cosH < -1) {
      return { sunrise: '--:--', sunset: '--:--', type: 'polar_day' };
    }

    const H = Math.acos(cosH) * 180 / Math.PI;

    const y = Math.tan(epsilonRad / 2) * Math.tan(epsilonRad / 2);
    const E = 4 * (y * Math.sin(2 * L0 * Math.PI / 180) - 2 * 0.016708634 * Math.sin(Mrad)) * 180 / Math.PI;

    const sunriseUTC = 12 - H/15 - longitude/15 - E/60;
    const sunsetUTC = 12 + H/15 - longitude/15 - E/60;

    const sunrise = normalizeTime(sunriseUTC);
    const sunset = normalizeTime(sunsetUTC);

    return { sunrise, sunset, type: 'precise' };

  } catch (error) {
    console.error('Error calculating sunrise/sunset:', error);
    return { sunrise: '-', sunset: '-', type: 'error' };
  }
}

function getJulianDay(year, month, day) {
  if (month <= 2) {
    year -= 1;
    month += 12;
  }

  const A = Math.floor(year / 100);
  const B = 2 - A + Math.floor(A / 4);

  return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + B - 1524.5;
}

function normalizeTime(timeDecimal) {
  let hours = timeDecimal;
  while (hours < 0) hours += 24;
  while (hours >= 24) hours -= 24;

  const h = Math.floor(hours);
  const m = Math.round((hours - h) * 60);

  if (m >= 60) {
    return normalizeTime(h + 1);
  }

  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

function updateTimeDisplay() {
  const timeLabel = document.getElementById('timeLabel');
  const timeElement = document.getElementById('currentTime');
  const sunriseElement = document.getElementById('sunrise');
  const sunsetElement = document.getElementById('sunset');
  const now = new Date();

  const isLocalMode = timeLabel && !timeLabel.textContent.includes('UTC');

  if (isLocalMode && window.airportData) {
    const offset = window.airportData.timezoneOffset;
    const localTime = new Date(now.getTime() + (offset * 3600000));
    const hours = localTime.getUTCHours().toString().padStart(2, '0');
    const minutes = localTime.getUTCMinutes().toString().padStart(2, '0');
    timeElement.textContent = `${hours}:${minutes}`;

    if (window.airportData.sunriseUTC && window.airportData.sunriseUTC !== '-') {
      sunriseElement.textContent = convertUTCToLocal(window.airportData.sunriseUTC, offset);
    }

    if (window.airportData.sunsetUTC && window.airportData.sunsetUTC !== '-') {
      sunsetElement.textContent = convertUTCToLocal(window.airportData.sunsetUTC, offset);
    }

  } else if (isLocalMode && !window.airportData) {
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    timeElement.textContent = `${hours}:${minutes}`;

  } else {
    const hours = now.getUTCHours().toString().padStart(2, '0');
    const minutes = now.getUTCMinutes().toString().padStart(2, '0');
    timeElement.textContent = `${hours}:${minutes}`;

    if (window.airportData) {
      sunriseElement.textContent = window.airportData.sunriseUTC || '-';
      sunsetElement.textContent = window.airportData.sunsetUTC || '-';
    }
  }
}

function convertUTCToLocal(utcTime, timezoneOffset) {
  if (!utcTime || utcTime === '-' || utcTime === '--:--') return utcTime;

  const [hours, minutes] = utcTime.split(':').map(Number);
  const utcDate = new Date();
  utcDate.setUTCHours(hours, minutes, 0, 0);
  const localDate = new Date(utcDate.getTime() + (timezoneOffset * 3600000));
  const localHours = localDate.getUTCHours().toString().padStart(2, '0');
  const localMinutes = localDate.getUTCMinutes().toString().padStart(2, '0');

  return `${localHours}:${localMinutes}`;
}

function toggleTimeDisplay() {
  const timeLabel = document.getElementById('timeLabel');
  const sunriseLabel = document.getElementById('sunriseLabel');
  const sunsetLabel = document.getElementById('sunsetLabel');
  const lang = document.getElementById('language').value;

  if (!timeLabel) return;

  const isUTC = timeLabel.textContent.includes('UTC');

  if (isUTC) {
    if (lang === 'ru') {
      timeLabel.textContent = '–í—Ä–µ–º—è –º–µ—Å—Ç–Ω–æ–µ';
      if (sunriseLabel) sunriseLabel.textContent = '–í–æ—Å—Ö–æ–¥';
      if (sunsetLabel) sunsetLabel.textContent = '–ó–∞—Ö–æ–¥';
    } else {
      timeLabel.textContent = 'Local time';
      if (sunriseLabel) sunriseLabel.textContent = 'Sunrise';
      if (sunsetLabel) sunsetLabel.textContent = 'Sunset';
    }
  } else {
    if (lang === 'ru') {
      timeLabel.textContent = '–í—Ä–µ–º—è UTC';
      if (sunriseLabel) sunriseLabel.textContent = '–í–æ—Å—Ö–æ–¥';
      if (sunsetLabel) sunsetLabel.textContent = '–ó–∞—Ö–æ–¥';
    } else {
      timeLabel.textContent = 'Time UTC';
      if (sunriseLabel) sunriseLabel.textContent = 'Sunrise';
      if (sunsetLabel) sunsetLabel.textContent = 'Sunset';
    }
  }

  updateTimeDisplay();
}

function attachTimeClickHandlers() {
  const timeElement = document.getElementById('currentTime');
  const sunriseElement = document.getElementById('sunrise');
  const sunsetElement = document.getElementById('sunset');

  if (timeElement) {
    timeElement.style.cursor = 'pointer';
    timeElement.addEventListener('click', toggleTimeDisplay);
  }

  if (sunriseElement) {
    sunriseElement.style.cursor = 'pointer';
    sunriseElement.addEventListener('click', toggleTimeDisplay);
  }

  if (sunsetElement) {
    sunsetElement.style.cursor = 'pointer';
    sunsetElement.addEventListener('click', toggleTimeDisplay);
  }
}

// ========== –î–ï–ö–û–î–ò–†–û–í–©–ò–ö –°–û–°–¢–û–Ø–ù–ò–Ø –í–ü–ü ==========

class RunwayStateDecoder {
  constructor() {
    this.language = 'en';
    this.initializeCodes();
  }

  initializeCodes() {
    this.depositCodes = {
      '0': { en: 'Clear and dry', ru: '–°—É—Ö–∞—è' },
      '1': { en: 'Damp', ru: '–í–ª–∞–∂–Ω–∞—è' },
      '2': { en: 'Wet', ru: '–ú–æ–∫—Ä–∞—è' },
      '3': { en: 'Rime/Frost', ru: '–ò–∑–º–æ—Ä–æ–∑—å' },
      '4': { en: 'Dry snow', ru: '–°—É—Ö–æ–π —Å–Ω–µ–≥' },
      '5': { en: 'Wet snow', ru: '–ú–æ–∫—Ä—ã–π —Å–Ω–µ–≥' },
      '6': { en: 'Slush', ru: '–°–ª—è–∫–æ—Ç—å' },
      '7': { en: 'Ice', ru: '–õ—ë–¥' },
      '8': { en: 'Frozen ruts', ru: '–ó–∞–º—ë—Ä–∑—à–∏–µ –∫–æ–ª–µ–∏' },
      '9': { en: 'Frozen ruts/ridges', ru: '–ó–∞–º—ë—Ä–∑—à–∏–µ –∫–æ–ª–µ–∏/–≥—Ä–µ–±–Ω–∏' },
      '/': { en: 'Not reported', ru: '–ù–µ —Å–æ–æ–±—â–∞–µ—Ç—Å—è' }
    };

    this.extentCodes = {
      '1': { en: '10% or less', ru: '10% –∏–ª–∏ –º–µ–Ω–µ–µ' },
      '2': { en: '11-25%', ru: '11-25%' },
      '5': { en: '26-50%', ru: '26-50%' },
      '9': { en: '51-100%', ru: '51-100%' },
      '/': { en: 'Not reported', ru: '–ù–µ —Å–æ–æ–±—â–∞–µ—Ç—Å—è' }
    };

    this.depthCodes = {
      '00': { en: 'Less than 1 mm', ru: '–ú–µ–Ω–µ–µ 1 –º–º' },
      '92': { en: '10 cm', ru: '10 —Å–º' },
      '93': { en: '15 cm', ru: '15 —Å–º' },
      '94': { en: '20 cm', ru: '20 —Å–º' },
      '95': { en: '25 cm', ru: '25 —Å–º' },
      '96': { en: '30 cm', ru: '30 —Å–º' },
      '97': { en: '35 cm', ru: '35 —Å–º' },
      '98': { en: '40 cm or more', ru: '40 —Å–º –∏–ª–∏ –±–æ–ª–µ–µ' },
      '99': { en: 'Not operationally significant', ru: '–ù–µ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω–æ' },
      '//': { en: 'Not reported', ru: '–ù–µ —Å–æ–æ–±—â–∞–µ—Ç—Å—è' }
    };

    this.frictionCodes = {
      '91': { en: 'Poor', ru: '–ü–ª–æ—Ö–æ–µ' },
      '92': { en: 'Medium/Poor', ru: '–°—Ä–µ–¥–Ω–µ–µ/–ü–ª–æ—Ö–æ–µ' },
      '93': { en: 'Medium', ru: '–°—Ä–µ–¥–Ω–µ–µ' },
      '94': { en: 'Medium/Good', ru: '–°—Ä–µ–¥–Ω–µ–µ/–•–æ—Ä–æ—à–µ–µ' },
      '95': { en: 'Good', ru: '–•–æ—Ä–æ—à–µ–µ' },
      '99': { en: 'Unreliable', ru: '–ù–µ–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω–æ' },
      '//': { en: 'Not reported', ru: '–ù–µ —Å–æ–æ–±—â–∞–µ—Ç—Å—è' }
    };
  }

  setLanguage(lang) {
    this.language = lang;
  }

  decodeRunwayState(metarString, runwayIdent) {
    console.log(`üîç decodeRunwayState called for runway: ${runwayIdent}`);

    if (!metarString || !runwayIdent) {
      console.log(`‚ö†Ô∏è Missing metarString or runwayIdent`);
      return this.getDefaultState();
    }

    if (currentMetarData && currentMetarData.runwayStates && currentMetarData.runwayStates.length > 0) {
      console.log(`üìã Found ${currentMetarData.runwayStates.length} runway states in METAR`);

      const runwayNumber = this.extractRunwayNumber(runwayIdent);
      console.log(`üî¢ Looking for runway number: ${runwayNumber} (from ${runwayIdent})`);

      const matchingState = currentMetarData.runwayStates.find(state => {
        const matches = state.runway === runwayNumber || state.runway === '88';
        console.log(`  Checking state runway ${state.runway}: ${matches ? '‚úÖ MATCH' : '‚ùå'}`);
        return matches;
      });

      if (matchingState) {
        console.log(`‚úÖ Found matching state:`, matchingState);
        return this.parseStateFromObject(matchingState);
      } else {
        console.log(`‚ö†Ô∏è No matching state found for runway ${runwayNumber}`);
      }
    } else {
      console.log(`‚ö†Ô∏è No runway states in currentMetarData`);
    }

    return this.getDefaultState();
  }

  extractRunwayNumber(runwayIdent) {
    if (!runwayIdent) return '00';
    // –£–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ–±–µ–ª—ã, –Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º L/R/C
    const cleaned = runwayIdent.trim();
    // –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ –Ω–æ–º–µ—Ä —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º (12L, 12R, 12C), –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å —Å –≤–µ–¥—É—â–∏–º –Ω—É–ª—ë–º –¥–ª—è –Ω–æ–º–µ—Ä–∞
    if (cleaned.match(/^\d{1,2}[LRC]?$/)) {
      const number = cleaned.match(/^(\d{1,2})/)[1];
      const indicator = cleaned.match(/[LRC]$/)?.[0] || '';
      return number.padStart(2, '0') + indicator;
    }
    return '00';
  }

  parseStateFromObject(stateObject) {
    const result = {
      raw: stateObject.raw,
      runway: stateObject.runway === '88' ? 'All' : stateObject.runway,
      deposit: this.decodeDeposit(stateObject.deposit),
      extent: this.decodeExtent(stateObject.extent),
      depth: this.decodeDepth(stateObject.depth),
      friction: this.decodeFriction(stateObject.friction),
      depositCode: stateObject.deposit,
      extentCode: stateObject.extent,
      depthCode: stateObject.depth,
      frictionCode: stateObject.friction
    };

    console.log(`üìä Decoded runway state:`, result);
    return result;
  }

  decodeDeposit(code) {
    const deposit = this.depositCodes[code];
    return deposit ? deposit[this.language] : 'Unknown';
  }

  decodeExtent(code) {
    const extent = this.extentCodes[code];
    return extent ? extent[this.language] : 'Unknown';
  }

  decodeDepth(code) {
    if (this.depthCodes[code]) {
      return this.depthCodes[code][this.language];
    }

    const numCode = parseInt(code);
    if (!isNaN(numCode) && numCode >= 1 && numCode <= 90) {
      return this.language === 'ru' ? `${numCode} –º–º` : `${numCode} mm`;
    }

    return this.language === 'ru' ? '–ù–µ —Å–æ–æ–±—â–∞–µ—Ç—Å—è' : 'Not reported';
  }

  decodeFriction(code) {
    if (this.frictionCodes[code]) {
      return this.frictionCodes[code][this.language];
    }

    const numCode = parseInt(code);
    if (!isNaN(numCode) && numCode >= 0 && numCode <= 90) {
      return (numCode / 100).toFixed(2);
    }

    return this.language === 'ru' ? '–ù–µ —Å–æ–æ–±—â–∞–µ—Ç—Å—è' : 'Not reported';
  }

  getDefaultState() {
    return {
      raw: null,
      runway: null,
      deposit: '-',
      extent: '-',
      depth: '-',
      friction: '-',
      depositCode: null,
      extentCode: null,
      depthCode: null,
      frictionCode: null
    };
  }
}

window.runwayStateDecoder = new RunwayStateDecoder();

window.decodeRunwayState = function(metarString, runwayIdent, language = 'ru') {
  window.runwayStateDecoder.setLanguage(language);
  return window.runwayStateDecoder.decodeRunwayState(metarString, runwayIdent);
};

// ========== –î–ï–ö–û–î–ò–†–û–í–©–ò–ö –û–ë–õ–ê–ß–ù–û–°–¢–ò ==========

class CloudDecoder {
  constructor() {
    this.language = 'en';
    this.initializeCloudCodes();
  }

  initializeCloudCodes() {
    this.coverageCodes = {
      'SKC': { en: 'Sky Clear', ru: '–Ø—Å–Ω–æ', priority: 1 },
      'CLR': { en: 'Clear', ru: '–Ø—Å–Ω–æ', priority: 1 },
      'NSC': { en: 'No Significant Cloud', ru: '–ù–µ—Ç –∑–Ω–∞—á–∏–º—ã—Ö –æ–±–ª–∞–∫–æ–≤', priority: 1 },
      'NCD': { en: 'No Cloud Detected', ru: '–û–±–ª–∞–∫–∞ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã', priority: 1 },
      'FEW': { en: 'Few', ru: '–ù–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ', priority: 2 },
      'SCT': { en: 'Scattered', ru: '–†–∞—Å—Å–µ—è–Ω–Ω—ã–µ', priority: 3 },
      'BKN': { en: 'Broken', ru: '–ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ', priority: 4 },
      'OVC': { en: 'Overcast', ru: '–°–ø–ª–æ—à–Ω—ã–µ', priority: 5 },
      '///': { en: 'Cloud data not available', ru: '–î–∞–Ω–Ω—ã–µ –æ –æ–±–ª–∞—á–Ω–æ—Å—Ç–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã', priority: 0 }
    };

    this.cloudTypes = {
      'CB': { en: 'Cumulonimbus', ru: '–∫—É—á–µ–≤–æ-–¥–æ–∂–¥–µ–≤—ã–µ', significant: true },
      'TCU': { en: 'Towering Cumulus', ru: '–º–æ—â–Ω—ã–µ –∫—É—á–µ–≤—ã–µ', significant: true }
    };
  }

  setLanguage(lang) {
    this.language = lang;
  }

  decodeCloudiness(metarClouds) {
    if (!metarClouds || metarClouds.length === 0) {
      return {
        summary: this.language === 'ru' ? '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö' : 'No data',
        layers: [],
        ceiling: null,
        significantClouds: [],
        weatherImpact: 'none'
      };
    }

    const layers = [];
    let ceiling = null;
    const significantClouds = [];

    for (const cloud of metarClouds) {
      if (typeof cloud === 'object' && cloud.coverage && cloud.height !== undefined) {
        const decodedLayer = this.decodeCloudLayer(cloud);
        if (decodedLayer) {
          layers.push(decodedLayer);

          if (!ceiling && (cloud.coverage === 'BKN' || cloud.coverage === 'OVC')) {
            ceiling = {
              height: cloud.height,
              coverage: decodedLayer.coverage,
              type: decodedLayer.type
            };
          }

          if (decodedLayer.significant) {
            significantClouds.push(decodedLayer);
          }
        }
      }
    }

    const summary = this.generateCloudSummary(layers);
    const weatherImpact = this.assessWeatherImpact(layers, significantClouds);

    return {
      summary: summary,
      layers: layers,
      ceiling: ceiling,
      significantClouds: significantClouds,
      weatherImpact: weatherImpact
    };
  }

  decodeCloudLayer(cloud) {
    if (!cloud.coverage) return null;

    const coverage = this.coverageCodes[cloud.coverage];
    if (!coverage) return null;

    const layer = {
      code: `${cloud.coverage}${cloud.height ? String(Math.round(cloud.height/100)).padStart(3, '0') : ''}`,
      coverage: coverage[this.language],
      coverageCode: cloud.coverage,
      height: cloud.height,
      heightText: this.formatHeight(cloud.height),
      priority: coverage.priority,
      significant: false,
      type: null
    };

    if (cloud.type && this.cloudTypes[cloud.type]) {
      const cloudType = this.cloudTypes[cloud.type];
      layer.type = cloudType[this.language];
      layer.significant = cloudType.significant;
    }

    return layer;
  }

  formatHeight(height) {
    if (height === null || height === undefined) return '';
    return this.language === 'ru' ? `${height} —Ñ—Ç` : `${height} ft`;
  }

  generateCloudSummary(layers) {
    if (layers.length === 0) {
      return this.language === 'ru' ? '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö' : 'No data';
    }

    const layerDescriptions = layers.map(layer => {
      const typeText = layer.type ? ` ${layer.type}` : '';
      const preposition = this.language === 'ru' ? '–Ω–∞' : 'at';

      if (layer.height && layer.height > 0) {
        return `${layer.coverage.toLowerCase()}${typeText} ${preposition} ${layer.heightText}`;
      } else {
        return `${layer.coverage.toLowerCase()}${typeText}`;
      }
    });

    const allLayers = layerDescriptions.join(',<br>');
    return this.formatFirstWordCapital(allLayers);
  }

  formatFirstWordCapital(text) {
    if (!text || text.trim() === '') return '';
    const trimmed = text.trim();
    return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
  }

  assessWeatherImpact(layers, significantClouds) {
    if (significantClouds.some(cloud => cloud.type && (cloud.type.includes('–∫—É—á–µ–≤–æ-–¥–æ–∂–¥–µ–≤—ã–µ') || cloud.type.includes('Cumulonimbus')))) {
      return 'severe';
    }

    if (significantClouds.some(cloud => cloud.type && (cloud.type.includes('–º–æ—â–Ω—ã–µ –∫—É—á–µ–≤—ã–µ') || cloud.type.includes('Towering')))) {
      return 'moderate';
    }

    const lowCeiling = layers.find(layer =>
      (layer.coverageCode === 'BKN' || layer.coverageCode === 'OVC') &&
      layer.height && layer.height < 1000
    );

    if (lowCeiling) return 'poor';

    const overcast = layers.find(layer => layer.coverageCode === 'OVC');
    if (overcast) return 'moderate';

    const broken = layers.find(layer => layer.coverageCode === 'BKN');
    if (broken) return 'fair';

    return 'good';
  }
}

window.cloudDecoder = new CloudDecoder();

window.decodeCloudiness = function(clouds, language = 'ru') {
  window.cloudDecoder.setLanguage(language);
  return window.cloudDecoder.decodeCloudiness(clouds);
};

// ========== –°–õ–û–í–ê–†–¨ –ü–û–ì–û–î–ù–´–• –Ø–í–õ–ï–ù–ò–ô ==========

const weatherHybridDictionary = {
  "+DZ": { en: "Heavy Drizzle", ru: "–°–∏–ª—å–Ω–∞—è –º–æ—Ä–æ—Å—å" },
  "+RA": { en: "Heavy Rain", ru: "–°–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å" },
  "+SN": { en: "Heavy Snow", ru: "–°–∏–ª—å–Ω—ã–π —Å–Ω–µ–≥" },
  "-DZ": { en: "Light Drizzle", ru: "–°–ª–∞–±–∞—è –º–æ—Ä–æ—Å—å" },
  "-RA": { en: "Light Rain", ru: "–°–ª–∞–±—ã–π –¥–æ–∂–¥—å" },
  "-SN": { en: "Light Snow", ru: "–°–ª–∞–±—ã–π —Å–Ω–µ–≥" },
  "DZ": { en: "Drizzle", ru: "–ú–æ—Ä–æ—Å—å" },
  "RA": { en: "Rain", ru: "–î–æ–∂–¥—å" },
  "SN": { en: "Snow", ru: "–°–Ω–µ–≥" },
  "SHRA": { en: "Showers of Rain", ru: "–õ–∏–≤–Ω–µ–≤–æ–π –¥–æ–∂–¥—å" },
  "SHSN": { en: "Snow Showers", ru: "–°–Ω–µ–∂–Ω—ã–µ –∑–∞—Ä—è–¥—ã" },
  "TS": { en: "Thunderstorm", ru: "–ì—Ä–æ–∑–∞" },
  "TSRA": { en: "Thunderstorm with Rain", ru: "–ì—Ä–æ–∑–∞ —Å –¥–æ–∂–¥—ë–º" },
  "FZDZ": { en: "Freezing Drizzle", ru: "–ü–µ—Ä–µ–æ—Ö–ª–∞–∂–¥—ë–Ω–Ω–∞—è –º–æ—Ä–æ—Å—å" },
  "FZRA": { en: "Freezing Rain", ru: "–ü–µ—Ä–µ–æ—Ö–ª–∞–∂–¥—ë–Ω–Ω—ã–π –¥–æ–∂–¥—å" },
  "BR": { en: "Mist", ru: "–î—ã–º–∫–∞" },
  "FG": { en: "Fog", ru: "–¢—É–º–∞–Ω" },
  "FU": { en: "Smoke", ru: "–î—ã–º" },
  "HZ": { en: "Haze", ru: "–ú–≥–ª–∞" }
};

const weatherIntensityMap = {
  "+": { en: "Heavy", ru: "–°–∏–ª—å–Ω—ã–π" },
  "-": { en: "Light", ru: "–°–ª–∞–±—ã–π" }
};

const weatherDescriptorMap = {
  SH: { en: "Showers", ru: "–õ–∏–≤–Ω–µ–≤—ã–π" },
  TS: { en: "Thunderstorm", ru: "–ì—Ä–æ–∑–∞" },
  FZ: { en: "Freezing", ru: "–ü–µ—Ä–µ–æ—Ö–ª–∞–∂–¥—ë–Ω–Ω—ã–π" },
  VC: { en: "In the vicinity", ru: "–í –æ–∫—Ä–µ—Å—Ç–Ω–æ—Å—Ç–∏" }
};

const weatherPhenomenaMap = {
  DZ: { en: "Drizzle", ru: "–ú–æ—Ä–æ—Å—å" },
  RA: { en: "Rain", ru: "–î–æ–∂–¥—å" },
  SN: { en: "Snow", ru: "–°–Ω–µ–≥" },
  BR: { en: "Mist", ru: "–î—ã–º–∫–∞" },
  FG: { en: "Fog", ru: "–¢—É–º–∞–Ω" },
  FU: { en: "Smoke", ru: "–î—ã–º" },
  HZ: { en: "Haze", ru: "–ú–≥–ª–∞" }
};

// ========== –ï–î–ò–ù–ê–Ø –û–¢–†–ò–°–û–í–ö–ê –ö–û–ú–ü–ê–°–û–í ==========

function drawCompassBase(compassId) {
  const c = document.getElementById(compassId);
  c.innerHTML = '';

  const r = c.getBoundingClientRect();
  const s = Math.min(r.width, r.height);
  const rad = s / 2;
  const cx = s / 2, cy = s / 2;

  for (let i = 0; i < 36; i++) {
    const a = i * 10;
    const radian = (a - 90) * Math.PI / 180;
    const m = document.createElement('div');
    const maj = i % 3 === 0;
    m.className = maj ? 'compass-mark major' : 'compass-mark minor';
    const ml = maj ? 18 : 12, mw = maj ? 2 : 1;

    const compassCircleRadius = rad - 2;
    const outerX = cx + Math.cos(radian) * compassCircleRadius;
    const outerY = cy + Math.sin(radian) * compassCircleRadius;
    const innerX = cx + Math.cos(radian) * (compassCircleRadius - ml);
    const innerY = cy + Math.sin(radian) * (compassCircleRadius - ml);
    const centerMarkX = (outerX + innerX) / 2;
    const centerMarkY = (outerY + innerY) / 2;

    m.style.left = (centerMarkX - mw / 2) + 'px';
    m.style.top = (centerMarkY - ml / 2) + 'px';
    m.style.width = mw + 'px';
    m.style.height = ml + 'px';
    m.style.transform = `rotate(${a}deg)`;
    m.style.transformOrigin = 'center';
    c.appendChild(m);

    if (a % 30 === 0) {
      const n = document.createElement('div');
      n.className = 'compass-number';
      const labels = ['36', '03', '06', '09', '12', '15', '18', '21', '24', '27', '30', '33'];
      n.textContent = labels[i / 3];

      const numberRadius = compassCircleRadius + 18;
      const nx = cx + Math.cos(radian) * numberRadius;
      const ny = cy + Math.sin(radian) * numberRadius;
      n.style.left = (nx - 12) + 'px';
      n.style.top = (ny - 8) + 'px';
      c.appendChild(n);
    }
  }
}

function addRunwayToCompass(compassId, runwayHeading) {
  const c = document.getElementById(compassId);

  const rw = document.createElement('div');
  rw.className = 'runway-display left-landing';
  rw.style.transform = `translate(-50%,-50%) rotate(${runwayHeading - 90}deg)`;
  c.appendChild(rw);
}

function addWindToCompass(compassId) {
  if (!currentMetarData) return;

  const c = document.getElementById(compassId);
  const container = c.parentElement;

  const windDisplay = container.querySelector('.wind-display');
  if (windDisplay) {
    const windDir = currentMetarData.wind.calm ? 0 : currentMetarData.wind.direction;
    let windSpeed = currentMetarData.wind.calm ? 0 : currentMetarData.wind.speed;
    let windGust = currentMetarData.wind.gust || 0;
    let windUnit = currentMetarData.windUnit || 'kt';

    // –ü–†–û–í–ï–†–ö–ê –ù–ê –®–¢–ò–õ–¨
    if (currentMetarData.wind.calm || windSpeed === 0) {
      const currentLang = document.getElementById('language')?.value || 'en';
      const calmText = currentLang === 'ru' ? '–¢–∏—Ö–æ' : 'Calm';

      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ç–æ–ª—å–∫–æ "Calm" –∏–ª–∏ "–¢–∏—Ö–æ" –±–µ–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –µ–¥–∏–Ω–∏—Ü
      windDisplay.querySelector('.wind-direction').textContent = calmText;
      windDisplay.querySelector('.wind-speed').textContent = '';
      windDisplay.querySelector('.wind-unit').textContent = '';

      console.log(`üå§Ô∏è CALM conditions for ${compassId}`);
      return;
    }

    // –û–ë–´–ß–ù–´–ï –£–°–õ–û–í–ò–Ø - –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –µ–¥–∏–Ω–∏—Ü –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if (userPreferredWindUnit && userPreferredWindUnit !== windUnit) {
      if (userPreferredWindUnit === 'kt' && windUnit === '–º/—Å') {
        windSpeed = Math.round(windSpeed * 1.944);
        windGust = windGust > 0 ? Math.round(windGust * 1.944) : 0;
        windUnit = 'kt';
      } else if (userPreferredWindUnit === '–º/—Å' && windUnit === 'kt') {
        windSpeed = Math.round(windSpeed / 1.944);
        windGust = windGust > 0 ? Math.round(windGust / 1.944) : 0;
        windUnit = '–º/—Å';
      }
    }

    windDisplay.querySelector('.wind-direction').textContent =
      `${windDir.toString().padStart(3, '0')}¬∞`;

    const windSpeedElement = windDisplay.querySelector('.wind-speed');
    const currentLang = document.getElementById('language')?.value || 'en';

    // –ü–û–õ–£–ß–ï–ù–ò–ï –°–¢–†–ï–õ–û–ö –¢–ï–ù–î–ï–ù–¶–ò–ò (–¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –ø–æ—Ä—ã–≤–æ–≤)
    const trendSymbol = getWindTrendSymbol();
    const trendColor = getWindTrendColor();
    const gustTrendSymbol = getGustTrendSymbol();
    const gustTrendColor = getGustTrendColor();

    if (windGust > 0 && windGust > windSpeed) {
      const gustText = currentLang === 'ru' ? '–ø–æ—Ä—ã–≤—ã' : 'gusts';

      // –° –ø–æ—Ä—ã–≤–∞–º–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±–µ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏
      let html = `${windSpeed}`;

      // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–µ–ª–∫—É –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
      if (trendSymbol) {
        html += ` <span style="color:${trendColor};font-weight:bold;margin-left:3px;">${trendSymbol}</span>`;
      }

      html += ` <span style="font-size:0.7em">${gustText}</span> ${windGust}`;

      // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–µ–ª–∫—É –¥–ª—è –ø–æ—Ä—ã–≤–æ–≤
      if (gustTrendSymbol) {
        html += ` <span style="color:${gustTrendColor};font-weight:bold;margin-left:3px;">${gustTrendSymbol}</span>`;
      }

      windSpeedElement.innerHTML = html;
    } else {
      // –ë–µ–∑ –ø–æ—Ä—ã–≤–æ–≤ - —Ç–æ–ª—å–∫–æ —Ç–µ–Ω–¥–µ–Ω—Ü–∏—è –æ—Å–Ω–æ–≤–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
      if (trendSymbol) {
        windSpeedElement.innerHTML = `${windSpeed} <span style="color:${trendColor};font-weight:bold;margin-left:3px;">${trendSymbol}</span>`;
      } else {
        windSpeedElement.textContent = windSpeed.toString();
      }
    }

    windDisplay.querySelector('.wind-unit').textContent = windUnit;
  }

  if (currentMetarData.wind.calm || currentMetarData.wind.speed === 0) return;

  if (currentMetarData.wind.variable) {
    const ws = document.createElement('div');
    ws.className = 'wind-sector variable';

    if (currentMetarData.variableFrom !== undefined && currentMetarData.variableTo !== undefined) {
      const r = c.getBoundingClientRect();
      const s = Math.min(r.width, r.height);
      const rad = s / 2;
      const cx = s / 2, cy = s / 2;

      const fromAngle = currentMetarData.variableFrom;
      const toAngle = currentMetarData.variableTo;
      let arcSpan = toAngle - fromAngle;
      if (arcSpan < 0) arcSpan += 360;

      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.style.position = "absolute";
      svg.style.top = "0";
      svg.style.left = "0";
      svg.style.width = "100%";
      svg.style.height = "100%";
      svg.style.pointerEvents = "none";

      const arcRadius = rad * 0.9;
      const startAngleRad = (fromAngle - 90) * Math.PI / 180;
      const endAngleRad = (toAngle - 90) * Math.PI / 180;

      const startX = cx + arcRadius * Math.cos(startAngleRad);
      const startY = cy + arcRadius * Math.sin(startAngleRad);
      const endX = cx + arcRadius * Math.cos(endAngleRad);
      const endY = cy + arcRadius * Math.sin(endAngleRad);

      const path = document.createElementNS(svgNS, "path");
      const largeArcFlag = arcSpan > 180 ? 1 : 0;
      const pathData = `M ${startX} ${startY} A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;

      path.setAttribute("d", pathData);
      path.setAttribute("stroke", "#4A90E2");
      path.setAttribute("stroke-width", "8");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-linecap", "round");
      path.setAttribute("opacity", "0.7");

      svg.appendChild(path);
      ws.appendChild(svg);
      ws.style.border = "none";
      ws.style.background = "none";
      ws.style.width = "100%";
      ws.style.height = "100%";
    }

    c.appendChild(ws);
  }

  const wa = document.createElement('div');
  wa.className = 'wind-arrow';

  const r = c.getBoundingClientRect();
  const s = Math.min(r.width, r.height);
  const rad = s / 2;
  const cx = s / 2, cy = s / 2;

  const windAngle = currentMetarData.wind.direction;
  const windRad = (windAngle - 90) * Math.PI / 180;
  const compassCircleRadius = rad - 2;
  const arrowStartRadius = compassCircleRadius - 15;

  const startX = cx + Math.cos(windRad) * arrowStartRadius;
  const startY = cy + Math.sin(windRad) * arrowStartRadius;

  wa.style.left = startX + 'px';
  wa.style.top = startY + 'px';
  wa.style.transform = `rotate(${windAngle}deg)`;
  c.appendChild(wa);
}

function initializeEmptyCompass(compassId) {
  drawCompassBase(compassId);
}

function initializeCompassWithRunway(compassId) {
  drawCompassBase(compassId);

  if (!currentRunwayData) return;

  let runwayHeading;
  if (compassId === 'compass') {
    const sel = document.getElementById('runwaySelect')?.value;
    if (sel) {
      runwayHeading = getRunwayHeading(sel);
    } else {
      runwayHeading = 0;
    }
  } else {
    const opp = document.getElementById('runwayDisplay2')?.textContent;
    if (opp && opp !== '--') {
      runwayHeading = getRunwayHeading(opp);
    } else {
      runwayHeading = 0;
    }
  }

  addRunwayToCompass(compassId, runwayHeading);
}

function initializeCompass(compassId) {
  drawCompassBase(compassId);

  if (currentRunwayData) {
    let runwayHeading;
    if (compassId === 'compass') {
      const sel = document.getElementById('runwaySelect')?.value;
      if (sel) {
        runwayHeading = getRunwayHeading(sel);
      } else {
        runwayHeading = 0;
      }
    } else {
      const opp = document.getElementById('runwayDisplay2')?.textContent;
      if (opp && opp !== '--') {
        runwayHeading = getRunwayHeading(opp);
      } else {
        runwayHeading = 0;
      }
    }

    addRunwayToCompass(compassId, runwayHeading);
  }

  addWindToCompass(compassId);
}

// ========== COMPASS-INFO –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

function initializeDefaultCompassInfo(compassIndex) {
  const compassInfo = document.querySelectorAll('.compass-info')[compassIndex];
  if (!compassInfo) return;

  compassInfo.innerHTML = '';

  const rvrRow = document.createElement('div');
  rvrRow.className = 'rvr-row compass-info-item';
  rvrRow.innerHTML = `
    <div class="section-label">RVR</div>
    <div class="data-field">-</div>
    <div class="units">–º</div>
  `;
  compassInfo.appendChild(rvrRow);

  const elevRow = document.createElement('div');
  elevRow.className = 'elev-row compass-info-item';
  elevRow.innerHTML = `
    <div class="section-label">ELEV</div>
    <div class="data-field">-</div>
    <div class="units">–º</div>
  `;
  compassInfo.appendChild(elevRow);

  const qfeRow = document.createElement('div');
  qfeRow.className = 'qfe-row';
  qfeRow.innerHTML = `
    <div class="qfe-fields">
      <div class="qfe-field primary">
        <div class="qfe-label">QFE</div>
        <div class="data-field">-</div>
        <div class="units">hPa</div>
      </div>
      <div class="qfe-field secondary">
        <div class="qfe-label" style="visibility:hidden">QFE</div>
        <div class="data-field">-</div>
        <div class="units">mmHg</div>
      </div>
      <div class="qfe-field secondary">
        <div class="qfe-label" style="visibility:hidden">QFE</div>
        <div class="data-field">-</div>
        <div class="units">inHg</div>
      </div>
    </div>
  `;
  compassInfo.appendChild(qfeRow);

  const runwayStateRow = document.createElement('div');
  runwayStateRow.className = 'runway-state-row';
  runwayStateRow.innerHTML = `
    <div class="runway-state-item surface">
      <div class="state-label">RWY</div>
      <div class="state-value">-</div>
    </div>
    <div class="runway-state-item contamination">
      <div class="state-label" style="visibility:hidden">RWY</div>
      <div class="state-value">-</div>
    </div>
    <div class="runway-state-item depth">
      <div class="state-label" style="visibility:hidden">RWY</div>
      <div class="state-value">-</div>
    </div>
    <div class="runway-state-item friction">
      <div class="state-label" style="visibility:hidden">RWY</div>
      <div class="state-value">-</div>
    </div>
  `;
  compassInfo.appendChild(runwayStateRow);
}

// ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï –î–ò–°–ü–õ–ï–ï–í ==========

function updateQFEDisplay(qfeId, qfeValue, elevation, compassIndex) {
  const compassInfo = document.querySelectorAll('.compass-info')[compassIndex];
  if (!compassInfo) return;

  if (qfeValue === null || qfeValue === undefined || isNaN(qfeValue) || qfeValue <= 0) {
    return;
  }

  const qfePressure = convertPressure(qfeValue);

  let qfeRow = compassInfo.querySelector('.qfe-row');
  if (!qfeRow) {
    qfeRow = document.createElement('div');
    qfeRow.className = 'qfe-row';
    const elevRow = compassInfo.querySelector('.elev-row');
    if (elevRow) {
      elevRow.after(qfeRow);
    } else {
      compassInfo.appendChild(qfeRow);
    }
  }

  qfeRow.innerHTML = `
    <div class="qfe-fields">
      <div class="qfe-field primary">
        <div class="qfe-label">QFE</div>
        <div class="data-field">${qfePressure.hpa}</div>
        <div class="units">hPa</div>
      </div>
      <div class="qfe-field secondary">
        <div class="qfe-label" style="visibility:hidden">QFE</div>
        <div class="data-field">${qfePressure.mmhg}</div>
        <div class="units">mmHg</div>
      </div>
      <div class="qfe-field secondary">
        <div class="qfe-label" style="visibility:hidden">QFE</div>
        <div class="data-field">${qfePressure.inhg}</div>
        <div class="units">inHg</div>
      </div>
    </div>
  `;

  let elevRow = compassInfo.querySelector('.elev-row');
  if (!elevRow) {
    elevRow = document.createElement('div');
    elevRow.className = 'elev-row compass-info-item';
    const rvrRow = compassInfo.querySelector('.rvr-row');
    if (rvrRow) {
      rvrRow.after(elevRow);
    } else {
      compassInfo.insertBefore(elevRow, qfeRow);
    }
  }

  elevRow.innerHTML = `
    <div class="section-label">ELEV</div>
    <div class="data-field">${elevation ? Math.round(elevation) : '-'}</div>
    <div class="units">–º</div>
  `;
}

function updateRunwayStateDisplay(compassIndex) {
  console.log(`üîÑ updateRunwayStateDisplay called for compass ${compassIndex}`);

  if (!currentMetarData || !currentMetarData.raw) {
    console.log(`‚ö†Ô∏è No current METAR data`);
    return;
  }

  const compassInfo = document.querySelectorAll('.compass-info')[compassIndex];
  if (!compassInfo) {
    console.log(`‚ö†Ô∏è No compass-info element found for index ${compassIndex}`);
    return;
  }

  let runwayIdent;
  if (compassIndex === 0) {
    runwayIdent = document.getElementById('runwaySelect')?.value;
  } else {
    runwayIdent = document.getElementById('runwayDisplay2')?.textContent;
  }

  console.log(`üõ´ Runway ident for compass ${compassIndex}: ${runwayIdent}`);

  if (!runwayIdent || runwayIdent === '--') {
    console.log(`‚ö†Ô∏è Invalid runway ident`);
    return;
  }

  const lang = document.getElementById('language')?.value || 'en';
  const runwayState = decodeRunwayState(currentMetarData.raw, runwayIdent, lang);

  console.log(`üìã Decoded runway state:`, runwayState);

  let existingState = compassInfo.querySelector('.runway-state-row');
  if (!existingState) {
    console.log(`‚ûï Creating new runway-state-row`);
    existingState = document.createElement('div');
    existingState.className = 'runway-state-row';
    compassInfo.appendChild(existingState);
  }

  existingState.innerHTML = `
    <div class="runway-state-item surface">
      <div class="state-label">RWY</div>
      <div class="state-value">${runwayState.deposit}</div>
    </div>
    <div class="runway-state-item contamination">
      <div class="state-label" style="visibility:hidden">RWY</div>
      <div class="state-value">${runwayState.extent}</div>
    </div>
    <div class="runway-state-item depth">
      <div class="state-label" style="visibility:hidden">RWY</div>
      <div class="state-value">${runwayState.depth}</div>
    </div>
  `;

  console.log(`‚úÖ Runway state display updated for compass ${compassIndex}`);

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ —Ç—Ä–µ–Ω–∏—è –≤ —ç–ª–µ–º–µ–Ω—Ç–µ —Å–ø—Ä–∞–≤–∞ –æ—Ç –∫–æ–º–ø–∞—Å–∞
  const frictionElement = compassInfo.parentElement.querySelector('.friction-coefficient .data-value');
  if (frictionElement) {
    frictionElement.textContent = runwayState.friction;
    console.log(`‚úÖ Friction coefficient updated: ${runwayState.friction}`);
  }
}

async function updateQFEForSelectedRunways() {
  if (!currentMetarData || !currentRunwayData) return;

  try {
    const api = await getAPI();

    let qfeSource = 'calculated';
    let qfeFromRemarks = null;

    if (window.metarQFE !== null && window.metarQFE !== undefined && !isNaN(window.metarQFE) && window.metarQFE > 0) {
      qfeFromRemarks = window.metarQFE;
      qfeSource = 'METAR remarks';
    }

    const selectedRunway1 = document.getElementById('runwaySelect').value;
    if (selectedRunway1) {
      const elevation1 = api.getRunwayElevation(currentRunwayData, selectedRunway1);
      let qfe1;
      if (qfeFromRemarks) {
        qfe1 = qfeFromRemarks;
      } else {
        qfe1 = api.calculateQFE(currentMetarData.pressure, elevation1);
      }
      updateQFEDisplay('qfe1', qfe1, elevation1, 0);
    }

    const selectedRunway2 = document.getElementById('runwayDisplay2').textContent;
    if (selectedRunway2 && selectedRunway2 !== '--') {
      const elevation2 = api.getRunwayElevation(currentRunwayData, selectedRunway2);
      let qfe2;
      if (qfeFromRemarks) {
        qfe2 = qfeFromRemarks;
      } else {
        qfe2 = api.calculateQFE(currentMetarData.pressure, elevation2);
      }
      updateQFEDisplay('qfe2', qfe2, elevation2, 1);
    }

  } catch (error) {
    console.error('‚ùå Error updating QFE:', error);
  }
}

function updateWeatherDisplay(data) {
  if (!data) return;

  if (data.specialConditions && data.specialConditions.qfe !== null) {
    window.metarQFE = data.specialConditions.qfe;
    console.log(`üéØ SETTING window.metarQFE = ${window.metarQFE} hPa`);
  } else {
    window.metarQFE = null;
    console.log(`üéØ CLEARING window.metarQFE`);
  }

  document.getElementById('metarCode').textContent = data.raw;

  if (data.pressure && data.pressure > 0) {
    const pressure = convertPressure(data.pressure);
    const allWeatherRows = document.querySelectorAll('.weather-row');
    let hpaField = null, mmhgField = null, inhgField = null;
    let tempField = null, dewField = null;

    allWeatherRows.forEach((row) => {
      const label = row.querySelector('.section-label');
      const value = row.querySelector('.data-value');
      const units = row.querySelector('.units');

      if (!value || !units) return;

      const labelText = label ? label.textContent.trim() : '';
      const unitsText = units.textContent.trim();

      if (unitsText === 'hPa' && !hpaField) {
        hpaField = value;
      } else if (unitsText === 'mmHg' && !mmhgField) {
        mmhgField = value;
      } else if (unitsText === 'inHg' && !inhgField) {
        inhgField = value;
      } else if (unitsText === '¬∞C' && labelText === 'T' && !tempField) {
        tempField = value;
      } else if (unitsText === '¬∞C' && labelText === 'DP' && !dewField) {
        dewField = value;
      }
    });

    if (hpaField) hpaField.textContent = pressure.hpa;
    if (mmhgField) mmhgField.textContent = pressure.mmhg;
    if (inhgField) inhgField.textContent = pressure.inhg;
    if (tempField) tempField.textContent = data.temperature !== null ? data.temperature : '-';
    if (dewField) dewField.textContent = data.dewpoint !== null ? data.dewpoint : '-';
  }

  const visEl = document.querySelector('#morLabel').parentElement.querySelector('.data-value');
  if (visEl) {
    visEl.textContent = data.visibility || '-';
  }

  const currentLanguage = document.getElementById('language').value === 'ru' ? 'ru' : 'en';
  const decodedClouds = decodeCloudiness(data.clouds, currentLanguage);

  const skyEl = document.querySelector('#skyConditionLabel').parentElement.querySelector('.data-value');
  if (skyEl) {
    skyEl.innerHTML = decodedClouds.summary;
  }

  const cloudBaseEl = document.querySelector('#qbbLabel').parentElement.querySelector('.data-value');
  const cloudBaseUnitsEl = document.querySelector('#qbbLabel').parentElement.querySelector('.units');

  if (cloudBaseEl && cloudBaseUnitsEl) {
    if (data.specialConditions && data.specialConditions.qbb !== null) {
      cloudBaseEl.textContent = data.specialConditions.qbb.toString();
      cloudBaseUnitsEl.textContent = currentLanguage === 'ru' ? '–º' : 'm';
    } else {
      let cloudBaseText = '-';

      const lowestCloudLayer = decodedClouds.layers
        .filter(layer => layer.height && layer.height > 0 &&
                       ['BKN', 'OVC', 'SCT', 'FEW'].includes(layer.coverageCode))
        .sort((a, b) => a.height - b.height)[0];

      if (lowestCloudLayer) {
        cloudBaseText = lowestCloudLayer.height.toString();
        cloudBaseUnitsEl.textContent = currentLanguage === 'ru' ? '—Ñ—Ç' : 'ft';
      }

      cloudBaseEl.textContent = cloudBaseText;
    }
  }

  const weatherEl = document.getElementById('weatherPhenomena');
  if (weatherEl) {
    if (data.weather && data.weather.length > 0) {
      const decodedWeather = data.weather.map(weatherCode => {
        if (weatherHybridDictionary[weatherCode]) {
          return weatherHybridDictionary[weatherCode][currentLanguage];
        }
        return weatherCode;
      });

      const finalWeatherText = decodedWeather.join(', ');
      weatherEl.textContent = finalWeatherText.charAt(0).toUpperCase() + finalWeatherText.slice(1);
    } else {
      weatherEl.textContent = '-';
    }
  }

  const specialEl = document.getElementById('specialConditions');
  if (specialEl) {
    if (data.specialConditions && data.specialConditions.other && data.specialConditions.other.length > 0) {
      const specialTexts = data.specialConditions.other.map(item => item.decoded);
      specialEl.textContent = specialTexts.join(', ');
    } else {
      specialEl.textContent = '-';
    }
  }

  console.log(`üîÑ Updating runway state displays...`);
  if (data.runwayStates && data.runwayStates.length > 0) {
    console.log(`‚úÖ Found ${data.runwayStates.length} runway states, updating displays`);
    updateRunwayStateDisplay(0);
    updateRunwayStateDisplay(1);
  } else {
    console.log(`‚ö†Ô∏è No runway states in data`);
  }

  updateSunriseSunset();
  if (currentRunwayData) {
    initializeCompass('compass');
    initializeCompass('compass2');
    updateWindComponents();
  }

  updateQFEForSelectedRunways();
}

// ========== –í–ü–ü ==========

async function updateRunwayOptions(icao) {
  const select = document.getElementById('runwaySelect');
  select.innerHTML = '<option value="">Loading runways...</option>';
  select.disabled = true;

  try {
    const api = await getAPI();
    currentRunwayData = await api.getRunwayData(icao);

    if (!currentRunwayData || currentRunwayData.length === 0) {
      throw new Error(`No runways found for ${icao}`);
    }

    const runwayList = [];
    currentRunwayData.forEach((runway) => {
      if (runway.leIdent && runway.leIdent !== '-' && runway.leIdent.trim() !== '') {
        runwayList.push(runway.leIdent.trim());
      }
      if (runway.heIdent && runway.heIdent !== '-' && runway.heIdent.trim() !== '') {
        runwayList.push(runway.heIdent.trim());
      }
    });

    const uniqueRunways = [...new Set(runwayList)].sort();

    if (uniqueRunways.length === 0) {
      throw new Error(`No valid runway identifiers found for ${icao}`);
    }

    select.innerHTML = '';
    uniqueRunways.forEach(runway => {
      const option = new Option(runway, runway);
      select.appendChild(option);
    });

    // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –í–´–ë–û–† –í–ü–ü –ò–ó METAR
    let selectedRunway = uniqueRunways[0]; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–≤–∞—è –í–ü–ü

    if (currentMetarData && currentMetarData.runwayStates && currentMetarData.runwayStates.length > 0) {
      // –ë–µ—Ä—ë–º –ø–µ—Ä–≤—É—é –í–ü–ü –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π –≤ METAR
      const firstRunwayInMetar = currentMetarData.runwayStates[0].runway;
      console.log(`üéØ –ü–µ—Ä–≤–∞—è –í–ü–ü –≤ METAR: ${firstRunwayInMetar}`);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–∞–∫–∞—è –í–ü–ü –≤ —Å–ø–∏—Å–∫–µ
      if (uniqueRunways.includes(firstRunwayInMetar)) {
        selectedRunway = firstRunwayInMetar;
        console.log(`‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±—Ä–∞–Ω–∞ –í–ü–ü –∏–∑ METAR: ${selectedRunway}`);
      } else {
        console.log(`‚ö†Ô∏è –í–ü–ü ${firstRunwayInMetar} –∏–∑ METAR –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–ø–∏—Å–∫–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –í–ü–ü`);
      }
    }

    select.value = selectedRunway;
    select.disabled = false;
    updateOppositeRunway();

    if (currentMetarData) {
      initializeCompass('compass');
      initializeCompass('compass2');
      updateWindComponents();
    } else {
      initializeCompassWithRunway('compass');
      initializeCompassWithRunway('compass2');
    }

    updateQFEForSelectedRunways();
    updateRunwayStateDisplay(0);
    updateRunwayStateDisplay(1);

    updateConnectionStatus('connected', `${uniqueRunways.length} runways loaded`);

  } catch (error) {
    console.error(`Failed to load runway data for ${icao}:`, error);
    select.innerHTML = '<option value="">No runway data</option>';
    select.disabled = true;
    document.getElementById('runwayDisplay2').textContent = '--';
    currentRunwayData = null;
    initializeEmptyCompass('compass');
    initializeEmptyCompass('compass2');
    updateConnectionStatus('error', `No runway data for ${icao}`);
  }
}

function updateOppositeRunway() {
  const sel = document.getElementById('runwaySelect').value;
  const opp = getOppositeRunway(sel);
  document.getElementById('runwayDisplay2').textContent = opp;

  if (currentMetarData) {
    initializeCompass('compass');
    initializeCompass('compass2');
    updateWindComponents();
  } else {
    initializeCompassWithRunway('compass');
    initializeCompassWithRunway('compass2');
  }

  updateQFEForSelectedRunways();
  updateRunwayStateDisplay(0);
  updateRunwayStateDisplay(1);
}

function getOppositeRunway(selectedRunway) {
  if (!currentRunwayData) return '--';

  for (const runway of currentRunwayData) {
    if (runway.leIdent === selectedRunway) {
      return runway.heIdent;
    }
    if (runway.heIdent === selectedRunway) {
      return runway.leIdent;
    }
  }
  return '--';
}

function getRunwayHeading(runwayIdent) {
  if (!currentRunwayData) return 0;

  for (const runway of currentRunwayData) {
    if (runway.leIdent === runwayIdent) return runway.leHeading;
    if (runway.heIdent === runwayIdent) return runway.heHeading;
  }

  const runwayNumber = parseInt(runwayIdent.replace(/[LRC]/g, ''));
  return runwayNumber * 10;
}

// ========== –¢–ï–ù–î–ï–ù–¶–ò–Ø –í–ï–¢–†–ê ==========

function getWindTrend() {
  if (!currentMetarData || !previousMetarData) {
    return null; // –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
  }

  // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–π - —à—Ç–∏–ª—å, –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–Ω–¥–µ–Ω—Ü–∏—é
  if (currentMetarData.wind.calm || previousMetarData.wind.calm) {
    return null;
  }

  const currentSpeed = currentMetarData.wind.speed || 0;
  const previousSpeed = previousMetarData.wind.speed || 0;

  // –ü–æ—Ä–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏—è - 2 –µ–¥–∏–Ω–∏—Ü—ã (—É–∑–ª—ã/–º/—Å)
  const threshold = 2;
  const difference = currentSpeed - previousSpeed;

  if (Math.abs(difference) < threshold) {
    return null; // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ
  }

  if (difference > 0) {
    return 'increasing'; // –í–µ—Ç–µ—Ä —É—Å–∏–ª–∏–ª—Å—è ‚Üë
  } else {
    return 'decreasing'; // –í–µ—Ç–µ—Ä –æ—Å–ª–∞–±–µ–ª ‚Üì
  }
}

function getGustTrend() {
  if (!currentMetarData || !previousMetarData) {
    return null; // –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
  }

  // –ï—Å–ª–∏ –Ω–µ—Ç –ø–æ—Ä—ã–≤–æ–≤ –≤ —Ç–µ–∫—É—â–µ–º –∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–º, –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–Ω–¥–µ–Ω—Ü–∏—é
  const currentGust = currentMetarData.wind.gust || 0;
  const previousGust = previousMetarData.wind.gust || 0;

  if (currentGust === 0 || previousGust === 0) {
    return null;
  }

  // –ü–æ—Ä–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏—è - 2 –µ–¥–∏–Ω–∏—Ü—ã
  const threshold = 2;
  const difference = currentGust - previousGust;

  if (Math.abs(difference) < threshold) {
    return null; // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ
  }

  if (difference > 0) {
    return 'increasing'; // –ü–æ—Ä—ã–≤—ã —É—Å–∏–ª–∏–ª–∏—Å—å ‚Üë
  } else {
    return 'decreasing'; // –ü–æ—Ä—ã–≤—ã –æ—Å–ª–∞–±–µ–ª–∏ ‚Üì
  }
}

function getWindTrendSymbol() {
  const trend = getWindTrend();
  if (!trend) return '';

  return trend === 'increasing' ? '‚Üë' : '‚Üì';
}

function getGustTrendSymbol() {
  const trend = getGustTrend();
  if (!trend) return '';

  return trend === 'increasing' ? '‚Üë' : '‚Üì';
}

function getWindTrendColor() {
  const trend = getWindTrend();
  if (!trend) return '';

  return trend === 'increasing' ? '#e74c3c' : '#40c767'; // –ö—Ä–∞—Å–Ω—ã–π/–ó–µ–ª—ë–Ω—ã–π
}

function getGustTrendColor() {
  const trend = getGustTrend();
  if (!trend) return '';

  return trend === 'increasing' ? '#e74c3c' : '#40c767'; // –ö—Ä–∞—Å–Ω—ã–π/–ó–µ–ª—ë–Ω—ã–π
}

// ========== –†–ê–°–ß–Å–¢ –ö–û–ú–ü–û–ù–ï–ù–¢–û–í –í–ï–¢–†–ê ==========

function calculateWindComponents(windDir, windSpeed, runwayHeading) {
  const windAngleRad = (windDir - runwayHeading) * Math.PI / 180;
  const headwind = Math.round(windSpeed * Math.cos(windAngleRad) * 10) / 10;
  const crosswind = Math.round(windSpeed * Math.sin(windAngleRad) * 10) / 10;
  return { headwind, crosswind };
}

function updateWindComponents() {
  if (!currentMetarData || !currentRunwayData) return;

  const windDir = currentMetarData.wind.calm ? 0 : currentMetarData.wind.direction;
  const windSpeed = currentMetarData.wind.calm ? 0 : currentMetarData.wind.speed;

  const selectedRunway1 = document.getElementById('runwaySelect').value;
  if (selectedRunway1) {
    const runwayHeading = getRunwayHeading(selectedRunway1);
    const components1 = calculateWindComponents(windDir, windSpeed, runwayHeading);

    const lateral1 = document.querySelector('#compass').parentElement.querySelector('.lateral-component .data-value');
    const headwind1 = document.querySelector('#compass').parentElement.querySelector('.headwind-component .data-value');

    if (lateral1) {
      const value = components1.crosswind;
      lateral1.textContent = value > 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
    }
    if (headwind1) {
      const value = components1.headwind;
      headwind1.textContent = value > 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
    }
  }

  const selectedRunway2 = document.getElementById('runwayDisplay2').textContent;
  if (selectedRunway2 && selectedRunway2 !== '--') {
    const runwayHeading = getRunwayHeading(selectedRunway2);
    const components2 = calculateWindComponents(windDir, windSpeed, runwayHeading);

    const lateral2 = document.querySelector('#compass2').parentElement.querySelector('.lateral-component .data-value');
    const headwind2 = document.querySelector('#compass2').parentElement.querySelector('.headwind-component .data-value');

    if (lateral2) {
      const value = components2.crosswind;
      lateral2.textContent = value > 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
    }
    if (headwind2) {
      const value = components2.headwind;
      headwind2.textContent = value > 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
    }
  }
}

// ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ==========

function handleIcaoInput() {
  const ii = document.getElementById('icaoInput');
  ii.addEventListener('input', async function() {
    const i = this.value.toUpperCase();
    this.value = i;

    if (i.length === 4) {
      if (!/^[A-Z0-9]{4}$/.test(i)) {
        updateConnectionStatus('error', 'Invalid ICAO code');
        return;
      }

      updateConnectionStatus('loading', `Loading data for ${i}...`);

      userPreferredWindUnit = null;

      try {
        const api = await getAPI();

        updateConnectionStatus('loading', `Loading data for ${i}...`);

        // –ì–ò–ë–†–ò–î–ù–ê–Ø –ó–ê–ì–†–£–ó–ö–ê METAR –° –ò–°–¢–û–†–ò–ï–ô
        await loadMetarWithHistory(i);
        console.log(`üì° METAR –∑–∞–≥—Ä—É–∂–µ–Ω, runway states:`, currentMetarData.runwayStates);
        console.log(`üìä Previous METAR available:`, !!previousMetarData);

        // –ó–ê–ì–†–£–ñ–ê–ï–ú –í–ü–ü (—Å –∞–≤—Ç–æ–≤—ã–±–æ—Ä–æ–º –∏–∑ METAR)
        await updateRunwayOptions(i);

        // –û–ë–ù–û–í–õ–Ø–ï–ú –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –ü–û–ì–û–î–´
        updateWeatherDisplay(currentMetarData);
        await updateSunriseSunset();

        if (updateInterval) clearInterval(updateInterval);
        updateInterval = setInterval(async () => {
          try {
            // –ü—Ä–∏ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–π –∫–∞–∫ –ø—Ä–µ–¥—ã–¥—É—â–∏–π
            previousMetarData = currentMetarData;
            currentMetarData = await fetchMetarData(i);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –¥–ª—è –±—É–¥—É—â–∏—Ö —Å–µ—Å—Å–∏–π
            saveMetarToLocalHistory(i, currentMetarData);

            updateWeatherDisplay(currentMetarData);

            // –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–Ω–¥–µ–Ω—Ü–∏—é
            const windTrend = getWindTrend();
            const gustTrend = getGustTrend();
            if (windTrend || gustTrend) {
              console.log('üìä Wind trend:', windTrend, '| Gust trend:', gustTrend);
            }
          } catch (error) {
            console.error('METAR auto-update failed:', error);
          }
        }, 30000);

        updateConnectionStatus('connected', `${i} data loaded`);

      } catch (error) {
        console.error(`Failed to load data for ${i}:`, error);
        updateConnectionStatus('error', `Failed to load ${i}`);
      }

    } else if (i.length === 0) {
      if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
      }

      currentMetarData = null;
      previousMetarData = null;
      currentRunwayData = null;
      userPreferredWindUnit = null;

      // –ù–µ –æ—á–∏—â–∞–µ–º localStorage - –∏—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –º–µ–∂–¥—É —Å–µ—Å—Å–∏—è–º–∏

      const select = document.getElementById('runwaySelect');
      select.innerHTML = '<option value="">Enter ICAO code</option>';
      select.disabled = true;
      document.getElementById('runwayDisplay2').textContent = '--';

      initializeEmptyCompass('compass');
      initializeEmptyCompass('compass2');

      initializeDefaultCompassInfo(0);
      initializeDefaultCompassInfo(1);

      updateConnectionStatus('', 'Enter ICAO code');

    } else {
      updateConnectionStatus('loading', `Type ${4 - i.length} more characters...`);
    }
  });
}

function toggleWindUnits() {
  const wu = document.querySelectorAll('.wind-unit');
  if (!wu || wu.length === 0) return;

  const currentUnit = wu[0].textContent;
  const isCurrentlyMps = currentUnit === '–º/—Å';
  const currentLang = document.getElementById('language')?.value || 'en';

  userPreferredWindUnit = isCurrentlyMps ? 'kt' : '–º/—Å';

  // –û–±–Ω–æ–≤–ª—è–µ–º –µ–¥–∏–Ω–∏—Ü—ã –∏–∑–º–µ—Ä–µ–Ω–∏—è
  wu.forEach(u => {
    if (isCurrentlyMps) {
      u.textContent = 'kt';
    } else {
      u.textContent = '–º/—Å';
    }
  });

  // –í–ê–ñ–ù–û: –í–º–µ—Å—Ç–æ —Ä—É—á–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ HTML, –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤–µ—Ç—Ä–∞
  // –∏—Å–ø–æ–ª—å–∑—É—è —Ñ—É–Ω–∫—Ü–∏—é addWindToCompass, –∫–æ—Ç–æ—Ä–∞—è –∑–Ω–∞–µ—Ç –æ —Ç–µ–Ω–¥–µ–Ω—Ü–∏—è—Ö
  if (currentMetarData) {
    addWindToCompass('compass');
    addWindToCompass('compass2');
  }
}

function applyTheme(t) {
  const b = document.body;
  const h = new Date().getHours();
  if (t === 'auto') {
    if (h >= 6 && h < 18) b.classList.remove('dark');
    else b.classList.add('dark');
  } else if (t === 'dark') b.classList.add('dark');
  else b.classList.remove('dark');
}

function applyLanguage(lang) {
  if (lang === 'ru') {
    document.getElementById('timeLabel').textContent = '–í—Ä–µ–º—è UTC';
    document.getElementById('sunriseLabel').textContent = '–í–æ—Å—Ö–æ–¥';
    document.getElementById('sunsetLabel').textContent = '–ó–∞—Ö–æ–¥';
    document.getElementById('weatherLabel').textContent = '–Ø–≤–ª–µ–Ω–∏—è –ø–æ–≥–æ–¥—ã';
    document.getElementById('morLabel').textContent = '–í–∏–¥–∏–º–æ—Å—Ç—å';
    document.getElementById('qbbLabel').textContent = '–í–ù–ì–û';
    document.getElementById('skyConditionLabel').textContent = '–û–±–ª–∞—á–Ω–æ—Å—Ç—å';
    document.getElementById('forecastLabel').textContent = '–ü—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥—ã';
    document.getElementById('specialLabel').textContent = '–û—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è';
    document.getElementById('lateralLabel1').textContent = '–ë–æ–∫–æ–≤–∞—è';
    document.getElementById('headwindLabel1').textContent = '–í—Å—Ç—Ä–µ—á–Ω–∞—è';
    document.getElementById('frictionLabel1').textContent = '–ö–°—Ü';
    document.getElementById('lateralLabel2').textContent = '–ë–æ–∫–æ–≤–∞—è';
    document.getElementById('headwindLabel2').textContent = '–í—Å—Ç—Ä–µ—á–Ω–∞—è';
    document.getElementById('frictionLabel2').textContent = '–ö–°—Ü';

    const morUnits = document.querySelector('#morLabel').parentElement.querySelector('.units');
    if (morUnits) morUnits.textContent = '–º';

  } else {
    document.getElementById('timeLabel').textContent = 'Time UTC';
    document.getElementById('sunriseLabel').textContent = 'Sunrise';
    document.getElementById('sunsetLabel').textContent = 'Sunset';
    document.getElementById('weatherLabel').textContent = 'Weather';
    document.getElementById('morLabel').textContent = 'Visibility';
    document.getElementById('qbbLabel').textContent = 'QBB';
    document.getElementById('skyConditionLabel').textContent = 'Sky condition';
    document.getElementById('forecastLabel').textContent = 'Weather forecast';
    document.getElementById('specialLabel').textContent = 'Special conditions';
    document.getElementById('lateralLabel1').textContent = 'Side';
    document.getElementById('headwindLabel1').textContent = 'Head';
    document.getElementById('frictionLabel1').textContent = 'Breaking action';
    document.getElementById('lateralLabel2').textContent = 'Side';
    document.getElementById('headwindLabel2').textContent = 'Head';
    document.getElementById('frictionLabel2').textContent = 'Breaking action';

    const morUnits = document.querySelector('#morLabel').parentElement.querySelector('.units');
    if (morUnits) morUnits.textContent = 'm';
  }

  if (currentMetarData && currentMetarData.wind.gust > 0) {
    const windSpeedElements = document.querySelectorAll('.wind-speed');
    windSpeedElements.forEach(el => {
      const html = el.innerHTML;
      if (html.includes('<span') && (html.includes('gusts') || html.includes('–ø–æ—Ä—ã–≤—ã'))) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const text = tempDiv.textContent;
        const numbers = text.match(/\d+/g);

        if (numbers && numbers.length >= 2) {
          const speed = numbers[0];
          const gust = numbers[1];
          const gustText = lang === 'ru' ? '–ø–æ—Ä—ã–≤—ã' : 'gusts';
          el.innerHTML = `${speed} <span style="font-size:0.7em">${gustText}</span> ${gust}`;
        }
      }
    });
  }

  if (currentMetarData) {
    updateWeatherDisplay(currentMetarData);
  }

  if (!currentMetarData || !currentRunwayData) {
    initializeDefaultCompassInfo(0);
    initializeDefaultCompassInfo(1);
  }
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

document.addEventListener('DOMContentLoaded', function() {
  initializeEmptyCompass('compass');
  initializeEmptyCompass('compass2');

  initializeDefaultCompassInfo(0);
  initializeDefaultCompassInfo(1);

  window.mainTimeInterval = setInterval(() => {
    const tl = document.getElementById('timeLabel');
    if (tl && tl.textContent.includes('UTC')) {
      const now = new Date();
      const hours = now.getUTCHours().toString().padStart(2, '0');
      const minutes = now.getUTCMinutes().toString().padStart(2, '0');
      document.getElementById('currentTime').textContent = `${hours}:${minutes}`;
    }
  }, 1000);

  attachTimeClickHandlers();
  setInterval(updateTimeDisplay, 1000);

  document.getElementById('theme').addEventListener('change', function() {
    applyTheme(this.value);
  });

  document.getElementById('language').addEventListener('change', function() {
    applyLanguage(this.value);
  });

  applyTheme('auto');
  applyLanguage('en');
  handleIcaoInput();

  document.getElementById('runwaySelect').addEventListener('change', function() {
    updateOppositeRunway();
  });

  document.querySelectorAll('.wind-direction, .wind-speed, .wind-unit').forEach(element => {
    element.style.cursor = 'pointer';
    element.addEventListener('click', toggleWindUnits);
  });

  window.addEventListener('resize', function() {
    setTimeout(() => {
      if (currentRunwayData && currentMetarData) {
        initializeCompass('compass');
        initializeCompass('compass2');
      } else if (currentRunwayData) {
        initializeCompassWithRunway('compass');
        initializeCompassWithRunway('compass2');
      } else {
        initializeEmptyCompass('compass');
        initializeEmptyCompass('compass2');
      }
    }, 100);
  });

  console.log('‚úÖ Application initialized - v1.0.16 - Hybrid METAR History (API + localStorage)');
});
</script>

</body>
</html>
